import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';

const jeepPhotoSwipeCss = "";

const JeepPhotoSwipe = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.onPhotoSwipe = createEvent(this, "jeepPhotoSwipe", 7);
    this._startPoint = {};
    this._endPoint = {};
    this._totalTime = 0;
    this._getSwipeDirection = (startPoint, endPoint, thresholdX, thresholdY) => {
      var swipeDirection = { up: false, right: false, down: false, left: false };
      if (startPoint.x > endPoint.x && startPoint.x - endPoint.x >= thresholdX)
        swipeDirection.left = true;
      else if (startPoint.x < endPoint.x && endPoint.x - startPoint.x >= thresholdX)
        swipeDirection.right = true;
      if (startPoint.y < endPoint.y && endPoint.y - startPoint.y >= thresholdY)
        swipeDirection.down = true;
      else if (startPoint.y > endPoint.y && startPoint.y - endPoint.y >= thresholdY)
        swipeDirection.up = true;
      return swipeDirection;
    };
    this.timeThreshold = 200;
    this.thresholdX = 100;
    this.thresholdY = 100;
    this.innerTimeThreshold = undefined;
    this.innerThresholdX = undefined;
    this.innerThresholdY = undefined;
  }
  //*****************************
  //* Watch on Property Changes *
  //*****************************
  parseTimeThreshold(newValue) {
    this.innerTimeThreshold = newValue;
  }
  parseThresholdX(newValue) {
    this.innerThresholdX = newValue;
  }
  parseThresholdY(newValue) {
    this.innerThresholdY = newValue;
  }
  //**********************
  //* Method Definitions *
  //**********************
  /**
   * Method initialize
   */
  async init() {
    return await this._init();
  }
  /**
   * handleTouchStart
   */
  async handleTouchStart(e) {
    this._startPoint.x = e.touches[0].clientX; //This is where touchstart coordinates are stored
    this._startPoint.y = e.touches[0].clientY;
    this._time = setInterval(() => {
      this._totalTime += 10;
    }, 10);
  }
  /**
   * handleTouchEnd
   */
  async handleTouchEnd(e) {
    this._endPoint.x = e.changedTouches[0].clientX;
    this._endPoint.y = e.changedTouches[0].clientY;
    // Let's stop calculating time and free up resources.
    clearInterval(this._time);
    if (this._totalTime >= this.innerTimeThreshold) {
      let res = this._getSwipeDirection(this._startPoint, this._endPoint, this.innerThresholdX, this.innerThresholdY);
      this.onPhotoSwipe.emit({ up: res.up, down: res.down, left: res.left, right: res.right });
    }
    this._totalTime = 0;
  }
  /**
   * handleMouseDown
   */
  async handleMouseDown(e) {
    e.preventDefault();
    this._startPoint.x = e.clientX; //This is where touchstart coordinates are stored
    this._startPoint.y = e.clientY;
    this._time = setInterval(() => {
      this._totalTime += 10;
    }, 10);
  }
  /**
   * handleMouseEUp
   */
  async handleMouseUp(e) {
    this._endPoint.x = e.clientX;
    this._endPoint.y = e.clientY;
    // Let's stop calculating time and free up resources.
    clearInterval(this._time);
    if (this._totalTime >= this.innerTimeThreshold) {
      let res = this._getSwipeDirection(this._startPoint, this._endPoint, this.innerThresholdX, this.innerThresholdY);
      this.onPhotoSwipe.emit({ up: res.up, down: res.down, left: res.left, right: res.right });
    }
    this._totalTime = 0;
  }
  //*******************************
  //* Component Lifecycle Methods *
  //*******************************
  async componentWillLoad() {
    this._window = window;
    await this.init();
  }
  //******************************
  //* Private Method Definitions *
  //******************************
  async _init() {
    this._element = this.el.shadowRoot;
    this.parseTimeThreshold(this.timeThreshold ? this.timeThreshold : 200);
    this.parseThresholdX(this.thresholdX ? this.thresholdX : 100);
    this.parseThresholdY(this.thresholdY ? this.thresholdY : 100);
    return;
  }
  //*************************
  //* Rendering JSX Element *
  //*************************
  render() {
    return (h(Host, null, h("div", { class: "swipe-container", onTouchStart: (e) => this.handleTouchStart(e), onTouchEnd: (e) => this.handleTouchEnd(e), onMouseDown: (e) => this.handleMouseDown(e), onMouseUp: (e) => this.handleMouseUp(e) }, h("slot", null))));
  }
  get el() { return this; }
  static get watchers() { return {
    "timeThreshold": ["parseTimeThreshold"],
    "thresholdX": ["parseThresholdX"],
    "thresholdY": ["parseThresholdY"]
  }; }
  static get style() { return jeepPhotoSwipeCss; }
}, [1, "jeep-photo-swipe", {
    "timeThreshold": [514, "timethreshold"],
    "thresholdX": [514, "thresholdx"],
    "thresholdY": [514, "thresholdy"],
    "innerTimeThreshold": [32],
    "innerThresholdX": [32],
    "innerThresholdY": [32],
    "init": [64],
    "handleTouchStart": [64],
    "handleTouchEnd": [64],
    "handleMouseDown": [64],
    "handleMouseUp": [64]
  }]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["jeep-photo-swipe"];
  components.forEach(tagName => { switch (tagName) {
    case "jeep-photo-swipe":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, JeepPhotoSwipe);
      }
      break;
  } });
}

export { JeepPhotoSwipe as J, defineCustomElement as d };
