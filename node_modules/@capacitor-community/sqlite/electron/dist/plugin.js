'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var require$$0 = require('sqlite3');
var require$$0$1 = require('node:fs/promises');
var require$$1 = require('path');
var require$$2 = require('fs');
var require$$3 = require('node-fetch');
var require$$4 = require('os');
var require$$5 = require('jszip');
var require$$6 = require('electron');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3);
var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
var require$$5__default = /*#__PURE__*/_interopDefaultLegacy(require$$5);
var require$$6__default = /*#__PURE__*/_interopDefaultLegacy(require$$6);

var src = {};

var Database$1 = {};

var exportToJson = {};

var utilsSQLite = {};

Object.defineProperty(utilsSQLite, "__esModule", { value: true });
utilsSQLite.UtilsSQLite = void 0;
const SQLITE_OPEN_READONLY = 1;
class UtilsSQLite {
    constructor() {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        //    this.JSQlite = require('@journeyapps/sqlcipher').verbose();
        this.SQLite3 = require$$0__default["default"];
    }
    /**
     * OpenOrCreateDatabase
     * @param pathDB
     * @param password
     */
    async openOrCreateDatabase(pathDB /*,
    password: string,*/, readonly) {
        const msg = 'OpenOrCreateDatabase: ';
        // open sqlite3 database
        let mDB;
        if (!readonly) {
            mDB = new this.SQLite3.Database(pathDB, {
                verbose: console.log,
            });
        }
        else {
            mDB = new this.SQLite3.Database(pathDB, SQLITE_OPEN_READONLY, {
                verbose: console.log,
            });
        }
        if (mDB != null) {
            try {
                await this.dbChanges(mDB);
            }
            catch (err) {
                return Promise.reject(msg + `dbChanges ${err}`);
            }
            try {
                /*        // set the password
                if (password.length > 0) {
                  await this.setCipherPragma(mDB, password);
                }
                */
                // set Foreign Keys On
                await this.setForeignKeyConstraintsEnabled(mDB, true);
            }
            catch (err) {
                return Promise.reject(msg + `${err}`);
            }
            return Promise.resolve(mDB);
        }
        else {
            return Promise.reject(msg + 'open database failed');
        }
    }
    /**
     * SetCipherPragma
     * @param mDB
     * @param password
     */
    /*
    public async setCipherPragma(mDB: any, password: string): Promise<void> {
      return new Promise((resolve, reject) => {
        mDB.serialize(() => {
          mDB.run('PRAGMA cipher_compatibility = 4');
          mDB.run(`PRAGMA key = '${password}'`, (err: any) => {
            if (err) {
              reject(new Error('SetForeignKey: ' + `${err.message}`));
            }
            resolve();
          });
        });
      });
    }
  */
    /**
     * SetForeignKeyConstraintsEnabled
     * @param mDB
     * @param toggle
     */
    async setForeignKeyConstraintsEnabled(mDB, toggle) {
        return new Promise((resolve, reject) => {
            let key = 'OFF';
            if (toggle) {
                key = 'ON';
            }
            mDB.run(`PRAGMA foreign_keys = '${key}'`, (err) => {
                if (err) {
                    reject(`SetForeignKey: ${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * GetVersion
     * @param mDB
     */
    async getVersion(mDB) {
        return new Promise((resolve, reject) => {
            let version = 0;
            const SELECT_VERSION = 'PRAGMA user_version;';
            mDB.get(SELECT_VERSION, [], (err, row) => {
                // process the row here
                if (err) {
                    reject('getVersion failed: ' + `${err.message}`);
                }
                else {
                    if (row == null) {
                        version = 0;
                    }
                    else {
                        const key = Object.keys(row)[0];
                        version = row[key];
                    }
                    resolve(version);
                }
            });
        });
    }
    /**
     * SetVersion
     * @param mDB
     * @param version
     */
    async setVersion(mDB, version) {
        return new Promise((resolve, reject) => {
            mDB.run(`PRAGMA user_version = ${version}`, (err) => {
                if (err) {
                    reject('setVersion failed: ' + `${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * ChangePassword
     * @param pathDB
     * @param password
     * @param newpassword
     */
    /*
  
    public async changePassword(
      pathDB: string,
      password: string,
      newpassword: string,
    ): Promise<void> {
      let mDB: any;
      try {
        mDB = await this.openOrCreateDatabase(pathDB, password);
        await this.pragmaReKey(mDB, password, newpassword);
      } catch (err) {
        return Promise.reject(err);
      } finally {
        mDB.close();
      }
    }
  */
    /**
     * PragmaReKey
     * @param mDB
     * @param password
     * @param newpassword
     */
    /*
    private async pragmaReKey(
      mDB: any,
      password: string,
      newpassword: string,
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        mDB.serialize(() => {
          mDB.run('PRAGMA cipher_compatibility = 4');
          mDB.run(`PRAGMA key = '${password}'`);
          mDB.run(`PRAGMA rekey = '${newpassword}'`, (err: any) => {
            if (err) {
              reject(new Error('ChangePassword: ' + `${err.message}`));
            }
            resolve();
          });
        });
      });
    }
  */
    /**
     * BeginTransaction
     * @param db
     * @param isOpen
     */
    async beginTransaction(db, isOpen) {
        // eslint-disable-next-line no-async-promise-executor
        return new Promise((resolve, reject) => {
            const msg = 'BeginTransaction: ';
            if (!isOpen) {
                return Promise.reject(`${msg}database not opened`);
            }
            const sql = 'BEGIN TRANSACTION;';
            db.run(sql, (err) => {
                if (err) {
                    reject(`${msg}${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * RollbackTransaction
     * @param db
     * @param isOpen
     */
    async rollbackTransaction(db, isOpen) {
        return new Promise((resolve, reject) => {
            const msg = 'RollbackTransaction: ';
            if (!isOpen) {
                reject(`${msg}database not opened`);
            }
            const sql = 'ROLLBACK TRANSACTION;';
            db.run(sql, (err) => {
                if (err) {
                    reject(`${msg}${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * CommitTransaction
     * @param db
     * @param isOpen
     */
    async commitTransaction(db, isOpen) {
        return new Promise((resolve, reject) => {
            const msg = 'CommitTransaction: ';
            if (!isOpen) {
                reject(`${msg}database not opened`);
            }
            const sql = 'COMMIT TRANSACTION;';
            db.run(sql, (err) => {
                if (err) {
                    reject(`${msg}${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * DbChanges
     * return total number of changes
     * @param db
     */
    async dbChanges(db) {
        return new Promise((resolve, reject) => {
            const SELECT_CHANGE = 'SELECT total_changes()';
            let changes = 0;
            db.get(SELECT_CHANGE, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`DbChanges failed: ${err.message}`);
                }
                else {
                    if (row == null) {
                        changes = 0;
                    }
                    else {
                        const key = Object.keys(row)[0];
                        changes = row[key];
                    }
                    resolve(changes);
                }
            });
        });
    }
    /**
     * GetLastId
     * @param db
     */
    getLastId(db) {
        return new Promise((resolve, reject) => {
            const SELECT_LAST_ID = 'SELECT last_insert_rowid()';
            let lastId = -1;
            db.get(SELECT_LAST_ID, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`GetLastId failed: ${err.message}`);
                }
                else {
                    if (row == null)
                        resolve(lastId);
                    const key = Object.keys(row)[0];
                    lastId = row[key];
                    resolve(lastId);
                }
            });
        });
    }
    /**
     * Execute
     * @param mDB
     * @param sql
     */
    async execute(mDB, sql, fromJson) {
        let changes = -1;
        let initChanges = -1;
        try {
            initChanges = await this.dbChanges(mDB);
            let sqlStmt = sql;
            // Check for DELETE FROM in sql string
            if (!fromJson &&
                sql.toLowerCase().includes('DELETE FROM'.toLowerCase())) {
                sqlStmt = sql.replace(/\n/g, '');
                const sqlStmts = sqlStmt.split(';');
                const resArr = [];
                for (const stmt of sqlStmts) {
                    const trimStmt = stmt
                        .trim()
                        .substring(0, Math.min(stmt.trim().length, 11))
                        .toUpperCase();
                    if (trimStmt === 'DELETE FROM' &&
                        stmt.toLowerCase().includes('WHERE'.toLowerCase())) {
                        const whereStmt = `${stmt.trim()};`;
                        const rStmt = await this.deleteSQL(mDB, whereStmt, []);
                        resArr.push(rStmt);
                    }
                    else {
                        resArr.push(stmt);
                    }
                }
                sqlStmt = resArr.join(';');
            }
            await this.execDB(mDB, sqlStmt);
            changes = (await this.dbChanges(mDB)) - initChanges;
            return Promise.resolve(changes);
        }
        catch (err) {
            const msg = err.message ? err.message : err;
            return Promise.reject(`Execute: ${msg}`);
        }
    }
    /**
     * ExecDB
     * @param mDB
     * @param sql
     */
    async execDB(mDB, sql) {
        return new Promise((resolve, reject) => {
            mDB.exec(sql, async (err) => {
                if (err) {
                    console.log(`in execDB err: ${JSON.stringify(err)}`);
                    reject(`Execute: ${err}: `);
                }
                resolve();
            });
        });
    }
    /**
     * ExecuteSet
     * @param db
     * @param set
     */
    async executeSet(db, set, fromJson) {
        let lastId = -1;
        for (let i = 0; i < set.length; i++) {
            const statement = 'statement' in set[i] ? set[i].statement : null;
            const values = 'values' in set[i] && set[i].values.length > 0 ? set[i].values : [];
            if (statement == null) {
                let msg = 'ExecuteSet: Error Nostatement';
                msg += ` for index ${i}`;
                return Promise.reject(msg);
            }
            try {
                if (Array.isArray(values[0])) {
                    for (const val of values) {
                        const mVal = await this.replaceUndefinedByNull(val);
                        lastId = await this.prepareRun(db, statement, mVal, fromJson);
                    }
                }
                else {
                    const mVal = await this.replaceUndefinedByNull(values);
                    lastId = await this.prepareRun(db, statement, mVal, fromJson);
                }
            }
            catch (err) {
                return Promise.reject(`ExecuteSet: ${err}`);
            }
        }
        return Promise.resolve(lastId);
    }
    /**
     * PrepareRun
     * @param db
     * @param statement
     * @param values
     */
    async prepareRun(db, statement, values, fromJson) {
        const stmtType = statement
            .replace(/\n/g, '')
            .trim()
            .substring(0, 6)
            .toUpperCase();
        let sqlStmt = statement;
        let lastId = -1;
        try {
            if (!fromJson && stmtType === 'DELETE') {
                sqlStmt = await this.deleteSQL(db, statement, values);
            }
            let mVal = [];
            if (values != null && values.length > 0) {
                mVal = await this.replaceUndefinedByNull(values);
            }
            await this.runExec(db, sqlStmt, mVal);
            lastId = await this.getLastId(db);
            return Promise.resolve(lastId);
        }
        catch (err) {
            return Promise.reject(`PrepareRun: ${err}`);
        }
    }
    async runExec(db, stmt, values = []) {
        return new Promise((resolve, reject) => {
            if (values != null && values.length > 0) {
                db.run(stmt, values, (err) => {
                    if (err) {
                        console.log(`in runExec err1: ${JSON.stringify(err)}`);
                        const msg = err.message ? err.message : err;
                        reject(msg);
                    }
                    else {
                        resolve();
                    }
                });
            }
            else {
                db.exec(stmt, (err) => {
                    if (err) {
                        console.log(`in runExec err2: ${JSON.stringify(err)}`);
                        const msg = err.message ? err.message : err;
                        reject(msg);
                    }
                    else {
                        resolve();
                    }
                });
            }
        });
    }
    /**
     * replaceUndefinedByNull
     * @param values
     * @returns
     */
    async replaceUndefinedByNull(values) {
        const retValues = [];
        if (values.length > 0) {
            for (const val of values) {
                let mVal = val;
                if (typeof val === 'undefined')
                    mVal = null;
                retValues.push(mVal);
            }
        }
        return Promise.resolve(retValues);
    }
    /**
     * deleteSQL
     * @param db
     * @param statement
     * @param values
     * @returns
     */
    async deleteSQL(db, statement, values) {
        let sqlStmt = statement;
        try {
            const isLast = await this.isLastModified(db, true);
            const isDel = await this.isSqlDeleted(db, true);
            if (isLast && isDel) {
                // Replace DELETE by UPDATE and set sql_deleted to 1
                const wIdx = statement.toUpperCase().indexOf('WHERE');
                const preStmt = statement.substring(0, wIdx - 1);
                const clauseStmt = statement.substring(wIdx, statement.length);
                const tableName = preStmt
                    .substring('DELETE FROM'.length)
                    .trim();
                sqlStmt = `UPDATE ${tableName} SET sql_deleted = 1 ${clauseStmt}`;
                // Find REFERENCES if any and update the sql_deleted column
                await this.findReferencesAndUpdate(db, tableName, clauseStmt, values);
            }
            return sqlStmt;
        }
        catch (err) {
            return Promise.reject(`DeleteSQL: ${err}`);
        }
    }
    /**
     * findReferencesAndUpdate
     * @param db
     * @param tableName
     * @param whereStmt
     * @param values
     * @returns
     */
    async findReferencesAndUpdate(db, tableName, whereStmt, values) {
        try {
            const references = await this.getReferences(db, tableName);
            if (references.length <= 0) {
                return;
            }
            const tableNameWithRefs = references.pop();
            for (const refe of references) {
                // get the tableName of the reference
                const refTable = await this.getReferenceTableName(refe);
                if (refTable.length <= 0) {
                    continue;
                }
                // get the with references columnName
                const withRefsNames = await this.getWithRefsColumnName(refe);
                if (withRefsNames.length <= 0) {
                    continue;
                }
                // get the referenced columnName
                const colNames = await this.getReferencedColumnName(refe);
                if (colNames.length <= 0) {
                    continue;
                }
                // update the where clause
                const uWhereStmt = await this.updateWhere(whereStmt, withRefsNames, colNames);
                if (uWhereStmt.length <= 0) {
                    continue;
                }
                let updTableName = tableNameWithRefs;
                let updColNames = colNames;
                if (tableNameWithRefs === tableName) {
                    updTableName = refTable;
                    updColNames = withRefsNames;
                }
                //update sql_deleted for this reference
                const stmt = 'UPDATE ' + updTableName + ' SET sql_deleted = 1 ' + uWhereStmt;
                if (values != null && values.length > 0) {
                    const mVal = await this.replaceUndefinedByNull(values);
                    let arrVal = whereStmt.split('?');
                    if (arrVal[arrVal.length - 1] === ';')
                        arrVal = arrVal.slice(0, -1);
                    const selValues = [];
                    for (const [j, val] of arrVal.entries()) {
                        for (const updVal of updColNames) {
                            const idxVal = val.indexOf(updVal);
                            if (idxVal > -1) {
                                selValues.push(mVal[j]);
                            }
                        }
                    }
                    await db.run(stmt, selValues);
                }
                else {
                    await db.exec(stmt);
                }
                const lastId = await this.getLastId(db);
                if (lastId == -1) {
                    const msg = `UPDATE sql_deleted failed for references table: ${refTable}`;
                    return Promise.reject(new Error(`findReferencesAndUpdate: ${msg}`));
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(new Error(`findReferencesAndUpdate: ${err.message}`));
        }
    }
    async getReferenceTableName(refValue) {
        let tableName = '';
        if (refValue.length > 0) {
            const arr = refValue.split(new RegExp('REFERENCES', 'i'));
            if (arr.length === 2) {
                const oPar = arr[1].indexOf('(');
                tableName = arr[1].substring(0, oPar).trim();
            }
        }
        return tableName;
    }
    async getReferencedColumnName(refValue) {
        let colNames = [];
        if (refValue.length > 0) {
            const arr = refValue.split(new RegExp('REFERENCES', 'i'));
            if (arr.length === 2) {
                const oPar = arr[1].indexOf('(');
                const cPar = arr[1].indexOf(')');
                const colStr = arr[1].substring(oPar + 1, cPar).trim();
                colNames = colStr.split(',');
            }
        }
        return colNames;
    }
    async getWithRefsColumnName(refValue) {
        let colNames = [];
        if (refValue.length > 0) {
            const arr = refValue.split(new RegExp('REFERENCES', 'i'));
            if (arr.length === 2) {
                const oPar = arr[0].indexOf('(');
                const cPar = arr[0].indexOf(')');
                const colStr = arr[0].substring(oPar + 1, cPar).trim();
                colNames = colStr.split(',');
            }
        }
        return colNames;
    }
    async updateWhere(whStmt, withRefsNames, colNames) {
        let whereStmt = '';
        if (whStmt.length > 0) {
            const index = whStmt.toLowerCase().indexOf('WHERE'.toLowerCase());
            const stmt = whStmt.substring(index + 6);
            if (withRefsNames.length === colNames.length) {
                for (let i = 0; i < withRefsNames.length; i++) {
                    let colType = 'withRefsNames';
                    let idx = stmt.indexOf(withRefsNames[i]);
                    if (idx === -1) {
                        idx = stmt.indexOf(colNames[i]);
                        colType = 'colNames';
                    }
                    if (idx > -1) {
                        let valStr = '';
                        const fEqual = stmt.indexOf('=', idx);
                        if (fEqual > -1) {
                            const iAnd = stmt.indexOf('AND', fEqual);
                            const ilAnd = stmt.indexOf('and', fEqual);
                            if (iAnd > -1) {
                                valStr = stmt.substring(fEqual + 1, iAnd - 1).trim();
                            }
                            else if (ilAnd > -1) {
                                valStr = stmt.substring(fEqual + 1, ilAnd - 1).trim();
                            }
                            else {
                                valStr = stmt.substring(fEqual + 1, stmt.length).trim();
                            }
                            if (i > 0) {
                                whereStmt += ' AND ';
                            }
                            if (colType === 'withRefsNames') {
                                whereStmt += `${colNames[i]} = ${valStr}`;
                            }
                            else {
                                whereStmt += `${withRefsNames[i]} = ${valStr}`;
                            }
                        }
                    }
                }
                whereStmt = 'WHERE ' + whereStmt;
            }
        }
        return whereStmt;
    }
    async getReferences(db, tableName) {
        const sqlStmt = 'SELECT sql FROM sqlite_master ' +
            "WHERE sql LIKE('%FOREIGN KEY%') AND sql LIKE('%REFERENCES%') AND " +
            "sql LIKE('%" +
            tableName +
            "%') AND sql LIKE('%ON DELETE%');";
        try {
            const res = await this.queryAll(db, sqlStmt, []);
            // get the reference's string(s)
            let retRefs = [];
            if (res.length > 0) {
                retRefs = await this.getRefs(res[0].sql);
            }
            return Promise.resolve(retRefs);
        }
        catch (err) {
            return Promise.reject(new Error(`getReferences: ${err.message}`));
        }
    }
    async getRefs(str) {
        const retRefs = [];
        const arrFor = str.split(new RegExp('FOREIGN KEY', 'i'));
        // Loop through Foreign Keys
        for (let i = 1; i < arrFor.length; i++) {
            retRefs.push(arrFor[i].split(new RegExp('ON DELETE', 'i'))[0].trim());
        }
        // find table name with references
        if (str.substring(0, 12).toLowerCase() === 'CREATE TABLE'.toLowerCase()) {
            const oPar = str.indexOf('(');
            const tableName = str.substring(13, oPar).trim();
            retRefs.push(tableName);
        }
        return retRefs;
    }
    /**
     * QueryAll
     * @param mDB
     * @param sql
     * @param values
     */
    queryAll(mDB, sql, values) {
        return new Promise((resolve, reject) => {
            mDB.serialize(() => {
                mDB.all(sql, values, (err, rows) => {
                    if (err) {
                        reject(`QueryAll: ${err.message}`);
                    }
                    else {
                        if (rows == null) {
                            rows = [];
                        }
                        resolve(rows);
                    }
                });
            });
        });
    }
    /**
     * GetTablesNames
     * @param mDb
     */
    async getTablesNames(mDb) {
        let sql = 'SELECT name FROM sqlite_master WHERE ';
        sql += "type='table' AND name NOT LIKE 'sync_table' ";
        sql += "AND name NOT LIKE '_temp_%' ";
        sql += "AND name NOT LIKE 'sqlite_%' ";
        sql += 'ORDER BY rootpage DESC;';
        const retArr = [];
        try {
            const retQuery = await this.queryAll(mDb, sql, []);
            for (const query of retQuery) {
                retArr.push(query.name);
            }
            return Promise.resolve(retArr);
        }
        catch (err) {
            return Promise.reject(`getTablesNames: ${err}`);
        }
    }
    /**
     * GetViewsNames
     * @param mDb
     */
    async getViewsNames(mDb) {
        let sql = 'SELECT name FROM sqlite_master WHERE ';
        sql += "type='view' AND name NOT LIKE 'sqlite_%' ";
        sql += 'ORDER BY rootpage DESC;';
        const retArr = [];
        try {
            const retQuery = await this.queryAll(mDb, sql, []);
            for (const query of retQuery) {
                retArr.push(query.name);
            }
            return Promise.resolve(retArr);
        }
        catch (err) {
            return Promise.reject(`getViewsNames: ${err}`);
        }
    }
    /**
     * isLastModified
     * @param db
     * @param isOpen
     */
    async isLastModified(db, isOpen) {
        if (!isOpen) {
            return Promise.reject('isLastModified: database not opened');
        }
        try {
            const tableList = await this.getTablesNames(db);
            for (const table of tableList) {
                const tableNamesTypes = await this.getTableColumnNamesTypes(db, table);
                const tableColumnNames = tableNamesTypes.names;
                if (tableColumnNames.includes('last_modified')) {
                    return Promise.resolve(true);
                }
            }
        }
        catch (err) {
            return Promise.reject(`isLastModified: ${err}`);
        }
    }
    /**
     * isSqlDeleted
     * @param db
     * @param isOpen
     */
    async isSqlDeleted(db, isOpen) {
        if (!isOpen) {
            return Promise.reject('isSqlDeleted: database not opened');
        }
        try {
            const tableList = await this.getTablesNames(db);
            for (const table of tableList) {
                const tableNamesTypes = await this.getTableColumnNamesTypes(db, table);
                const tableColumnNames = tableNamesTypes.names;
                if (tableColumnNames.includes('sql_deleted')) {
                    return Promise.resolve(true);
                }
            }
        }
        catch (err) {
            return Promise.reject(`isSqlDeleted: ${err}`);
        }
    }
    async getJournalMode(mDB) {
        let resQuery = [];
        let retMode = 'delete';
        const query = `PRAGMA journal_mode;`;
        try {
            resQuery = await this.queryAll(mDB, query, []);
            if (resQuery.length === 1) {
                for (const query of resQuery) {
                    retMode = query.journal_mode;
                }
            }
            return retMode;
        }
        catch (err) {
            return Promise.reject('GetJournalMode: ' + `${err}`);
        }
    }
    /**
     * GetTableColumnNamesTypes
     * @param mDB
     * @param tableName
     */
    async getTableColumnNamesTypes(mDB, tableName) {
        let resQuery = [];
        const retNames = [];
        const retTypes = [];
        const query = `PRAGMA table_info('${tableName}');`;
        try {
            resQuery = await this.queryAll(mDB, query, []);
            if (resQuery.length > 0) {
                for (const query of resQuery) {
                    retNames.push(query.name);
                    retTypes.push(query.type);
                }
            }
            return Promise.resolve({ names: retNames, types: retTypes });
        }
        catch (err) {
            return Promise.reject('GetTableColumnNamesTypes: ' + `${err}`);
        }
    }
}
utilsSQLite.UtilsSQLite = UtilsSQLite;

var utilsJson = {};

Object.defineProperty(utilsJson, "__esModule", { value: true });
utilsJson.UtilsJson = void 0;
const utilsSQLite_1$5 = utilsSQLite;
class UtilsJson {
    constructor() {
        this.sqliteUtil = new utilsSQLite_1$5.UtilsSQLite();
    }
    /**
     * IsTableExists
     * @param db
     * @param isOpen
     * @param tableName
     */
    async isTableExists(db, isOpen, tableName) {
        return new Promise((resolve, reject) => {
            if (!isOpen) {
                reject('isTableExists: database not opened');
            }
            let query = 'SELECT name FROM sqlite_master WHERE ';
            query += `type='table' AND name='${tableName}';`;
            db.all(query, [], (err, rows) => {
                // process the row here
                if (err) {
                    reject(`isTableExists: failed: ${err.message}`);
                }
                else {
                    if (rows.length === 0) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                }
            });
        });
    }
    /**
     * IsViewExists
     * @param db
     * @param isOpen
     * @param viewName
     */
    async isViewExists(db, isOpen, viewName) {
        return new Promise((resolve, reject) => {
            if (!isOpen) {
                reject('isViewExists: database not opened');
            }
            let query = 'SELECT name FROM sqlite_master WHERE ';
            query += `type='view' AND name='${viewName}';`;
            db.all(query, [], (err, rows) => {
                // process the row here
                if (err) {
                    reject(`isViewExists: failed: ${err.message}`);
                }
                else {
                    if (rows.length === 0) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                }
            });
        });
    }
    /**
     * CreateSchema
     * @param mDB
     * @param jsonData
     */
    async createSchema(mDB, jsonData) {
        // create the database schema
        let changes = 0;
        try {
            // start a transaction
            await this.sqliteUtil.beginTransaction(mDB, true);
        }
        catch (err) {
            return Promise.reject(`CreateDatabaseSchema: ${err}`);
        }
        const stmts = await this.createSchemaStatement(jsonData);
        if (stmts.length > 0) {
            const schemaStmt = stmts.join('\n');
            try {
                changes = await this.sqliteUtil.execute(mDB, schemaStmt, true);
                if (changes < 0) {
                    try {
                        await this.sqliteUtil.rollbackTransaction(mDB, true);
                    }
                    catch (err) {
                        return Promise.reject('CreateSchema: changes < 0 ' + `${err}`);
                    }
                }
            }
            catch (err) {
                const msg = err;
                try {
                    await this.sqliteUtil.rollbackTransaction(mDB, true);
                    return Promise.reject(`CreateSchema: ${msg}`);
                }
                catch (err) {
                    return Promise.reject('CreateSchema: changes < 0 ' + `${err}: ${msg}`);
                }
            }
        }
        try {
            await this.sqliteUtil.commitTransaction(mDB, true);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject('CreateSchema: commit ' + `${err}`);
        }
    }
    /**
     * CreateSchemaStatement
     * @param jsonData
     */
    async createSchemaStatement(jsonData) {
        const statements = [];
        let isLastModified = false;
        let isSqlDeleted = false;
        // Prepare the statement to execute
        try {
            for (const jTable of jsonData.tables) {
                if (jTable.schema != null && jTable.schema.length >= 1) {
                    // create table
                    statements.push('CREATE TABLE IF NOT EXISTS ' + `${jTable.name} (`);
                    for (let j = 0; j < jTable.schema.length; j++) {
                        if (j === jTable.schema.length - 1) {
                            if (jTable.schema[j].column) {
                                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value}`);
                                if (jTable.schema[j].column === 'last_modified') {
                                    isLastModified = true;
                                }
                                if (jTable.schema[j].column === 'sql_deleted') {
                                    isSqlDeleted = true;
                                }
                            }
                            else if (jTable.schema[j].foreignkey) {
                                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value}`);
                            }
                            else if (jTable.schema[j].constraint) {
                                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value}`);
                            }
                        }
                        else {
                            if (jTable.schema[j].column) {
                                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value},`);
                                if (jTable.schema[j].column === 'last_modified') {
                                    isLastModified = true;
                                }
                                if (jTable.schema[j].column === 'sql_deleted') {
                                    isSqlDeleted = true;
                                }
                            }
                            else if (jTable.schema[j].foreignkey) {
                                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value},`);
                            }
                            else if (jTable.schema[j].constraint) {
                                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value},`);
                            }
                        }
                    }
                    statements.push(');');
                    if (isLastModified && isSqlDeleted) {
                        // create trigger last_modified associated with the table
                        let trig = 'CREATE TRIGGER IF NOT EXISTS ';
                        trig += `${jTable.name}`;
                        trig += `_trigger_last_modified `;
                        trig += `AFTER UPDATE ON ${jTable.name} `;
                        trig += 'FOR EACH ROW WHEN NEW.last_modified < ';
                        trig += 'OLD.last_modified BEGIN UPDATE ';
                        trig += `${jTable.name} `;
                        trig += `SET last_modified = `;
                        trig += "(strftime('%s','now')) WHERE id=OLD.id; END;";
                        statements.push(trig);
                    }
                }
                if (jTable.indexes != null && jTable.indexes.length >= 1) {
                    for (const jIndex of jTable.indexes) {
                        const tableName = jTable.name;
                        let stmt = `CREATE ${Object.keys(jIndex).includes('mode') ? jIndex.mode + ' ' : ''} INDEX IF NOT EXISTS `;
                        stmt += `${jIndex.name} ON ${tableName} (${jIndex.value});`;
                        statements.push(stmt);
                    }
                }
                if (jTable.triggers != null && jTable.triggers.length >= 1) {
                    for (const jTrg of jTable.triggers) {
                        const tableName = jTable.name;
                        if (jTrg.timeevent.toUpperCase().endsWith(' ON')) {
                            jTrg.timeevent = jTrg.timeevent.substring(0, jTrg.timeevent.length - 3);
                        }
                        let stmt = `CREATE TRIGGER IF NOT EXISTS `;
                        stmt += `${jTrg.name} ${jTrg.timeevent} ON ${tableName} `;
                        if (jTrg.condition)
                            stmt += `${jTrg.condition} `;
                        stmt += `${jTrg.logic};`;
                        statements.push(stmt);
                    }
                }
            }
            return Promise.resolve(statements);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    /**
     * CreateDataTable
     * @param mDB
     * @param table
     * @param mode
     */
    async createDataTable(mDB, table, mode) {
        let lastId = -1;
        try {
            // Check if the table exists
            const tableExists = await this.isTableExists(mDB, true, table.name);
            if (!tableExists) {
                return Promise.reject('CreateDataTable: Table ' + `${table.name} does not exist`);
            }
            // Get the column names and types
            const tableNamesTypes = await this.sqliteUtil.getTableColumnNamesTypes(mDB, table.name);
            const tableColumnTypes = tableNamesTypes.types;
            const tableColumnNames = tableNamesTypes.names;
            if (tableColumnTypes.length === 0) {
                return Promise.reject('CreateDataTable: Table ' + `${table.name} info does not exist`);
            }
            // Loop on Table Values
            for (let j = 0; j < table.values.length; j++) {
                let row = table.values[j];
                let isRun = true;
                const stmt = await this.createRowStatement(mDB, tableColumnNames, row, j, table.name, mode);
                isRun = await this.checkUpdate(mDB, stmt, row, table.name, tableColumnNames);
                if (isRun) {
                    if (stmt.substring(0, 6).toUpperCase() === 'DELETE') {
                        row = [];
                    }
                    lastId = await this.sqliteUtil.prepareRun(mDB, stmt, row, true);
                    if (lastId < 0) {
                        return Promise.reject('CreateDataTable: lastId < 0');
                    }
                }
                else {
                    lastId = 0;
                }
            }
            return Promise.resolve(lastId);
        }
        catch (err) {
            return Promise.reject(`CreateDataTable: ${err}`);
        }
    }
    /**
     * CreateRowStatement
     * @param mDB
     * @param tColNames
     * @param row
     * @param j
     * @param tableName
     * @param mode
     * @returns
     */
    async createRowStatement(mDB, tColNames, row, j, tableName, mode) {
        // Check the row number of columns
        if (row.length != tColNames.length ||
            row.length === 0 ||
            tColNames.length === 0) {
            return Promise.reject(new Error(`CreateRowStatement: Table ${tableName} ` +
                `values row ${j} not correct length`));
        }
        try {
            const retisIdExists = await this.isIdExists(mDB, tableName, tColNames[0], row[0]);
            let stmt;
            if (mode === 'full' || (mode === 'partial' && !retisIdExists)) {
                // Insert
                const nameString = tColNames.join();
                const questionMarkString = await this.createQuestionMarkString(tColNames.length);
                stmt = `INSERT INTO ${tableName} (${nameString}) VALUES (`;
                stmt += `${questionMarkString});`;
            }
            else {
                // Update or Delete
                let isUpdate = true;
                const isColDeleted = (element) => element === `sql_deleted`;
                const idxDelete = tColNames.findIndex(isColDeleted);
                if (idxDelete >= 0) {
                    if (row[idxDelete] === 1) {
                        isUpdate = false;
                        stmt = `DELETE FROM ${tableName} WHERE `;
                        if (typeof row[0] == 'string') {
                            stmt += `${tColNames[0]} = '${row[0]}';`;
                        }
                        else {
                            stmt += `${tColNames[0]} = ${row[0]};`;
                        }
                    }
                }
                if (isUpdate) {
                    // Update
                    const setString = await this.setNameForUpdate(tColNames);
                    if (setString.length === 0) {
                        return Promise.reject(new Error(`CreateRowStatement: Table ${tableName} ` +
                            `values row ${j} not set to String`));
                    }
                    stmt = `UPDATE ${tableName} SET ${setString} WHERE `;
                    if (typeof row[0] == 'string') {
                        stmt += `${tColNames[0]} = '${row[0]}';`;
                    }
                    else {
                        stmt += `${tColNames[0]} = ${row[0]};`;
                    }
                }
            }
            return Promise.resolve(stmt);
        }
        catch (err) {
            return Promise.reject(new Error(`CreateRowStatement: ${err.message}`));
        }
    }
    /**
     *
     * @param db
     * @param values
     * @param tbName
     * @param tColNames
     * @returns
     */
    async checkUpdate(db, stmt, values, tbName, tColNames) {
        const isRun = true;
        if (stmt.substring(0, 6) === 'UPDATE') {
            try {
                let query = `SELECT * FROM ${tbName} WHERE `;
                if (typeof values[0] == 'string') {
                    query += `${tColNames[0]} = '${values[0]}';`;
                }
                else {
                    query += `${tColNames[0]} = ${values[0]};`;
                }
                const resQuery = await this.getValues(db, query, tbName);
                let resValues = [];
                if (resQuery.length > 0) {
                    resValues = resQuery[0];
                }
                if (values.length > 0 &&
                    resValues.length > 0 &&
                    values.length === resValues.length) {
                    for (let i = 0; i < values.length; i++) {
                        if (values[i] !== resValues[i]) {
                            return Promise.resolve(true);
                        }
                    }
                    return Promise.resolve(false);
                }
                else {
                    const msg = 'Both arrays not the same length';
                    return Promise.reject(new Error(`CheckUpdate: ${msg}`));
                }
            }
            catch (err) {
                return Promise.reject(new Error(`CheckUpdate: ${err.message}`));
            }
        }
        else {
            return Promise.resolve(isRun);
        }
    }
    /**
     * GetValues
     * @param mDb
     * @param query
     * @param tableName
     */
    async getValues(mDb, query, tableName) {
        const values = [];
        try {
            // get table column names and types
            const tableNamesTypes = await this.sqliteUtil.getTableColumnNamesTypes(mDb, tableName);
            let rowNames = [];
            if (Object.keys(tableNamesTypes).includes('names')) {
                rowNames = tableNamesTypes.names;
            }
            else {
                return Promise.reject(`GetValues: Table ${tableName} no names`);
            }
            const retValues = await this.sqliteUtil.queryAll(mDb, query, []);
            for (const rValue of retValues) {
                const row = [];
                for (const rName of rowNames) {
                    if (Object.keys(rValue).includes(rName)) {
                        row.push(rValue[rName]);
                    }
                    else {
                        row.push('NULL');
                    }
                }
                values.push(row);
            }
            return Promise.resolve(values);
        }
        catch (err) {
            return Promise.reject(`GetValues: ${err}`);
        }
    }
    /**
     * CheckColumnTypes
     * @param tableTypes
     * @param rowValues
     */
    /*
    private async checkColumnTypes(
      tableTypes: any[],
      rowValues: any[],
    ): Promise<boolean> {
      const isType = true;
      for (let i = 0; i < rowValues.length; i++) {
        if (rowValues[i].toString().toUpperCase() != 'NULL') {
          try {
            await this.isType(tableTypes[i], rowValues[i]);
          } catch (err) {
            return Promise.reject(new Error('checkColumnTypes: Type not found'));
          }
        }
      }
      return Promise.resolve(isType);
    }
  */
    /**
     * IsType
     * @param type
     * @param value
     */
    /*
    private async isType(type: string, value: any): Promise<void> {
      let ret = false;
      if (type === 'NULL' && typeof value === 'object') ret = true;
      if (type === 'TEXT' && typeof value === 'string') ret = true;
      if (type === 'INTEGER' && typeof value === 'number') ret = true;
      if (type === 'REAL' && typeof value === 'number') ret = true;
      if (type === 'BLOB' && typeof value === 'string') ret = true;
      if (ret) {
        return Promise.resolve();
      } else {
        return Promise.reject(new Error('IsType: not a SQL Type'));
      }
    }
  */
    /**
     * IsIdExists
     * @param db
     * @param dbName
     * @param firstColumnName
     * @param key
     */
    async isIdExists(db, dbName, firstColumnName, key) {
        let ret = false;
        let query = `SELECT ${firstColumnName} FROM ` +
            `${dbName} WHERE ${firstColumnName} = `;
        if (typeof key === 'number')
            query += `${key};`;
        if (typeof key === 'string')
            query += `'${key}';`;
        try {
            const resQuery = await this.sqliteUtil.queryAll(db, query, []);
            if (resQuery.length === 1)
                ret = true;
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(`IsIdExists: ${err}`);
        }
    }
    /**
     * CreateQuestionMarkString
     * @param length
     */
    createQuestionMarkString(length) {
        return new Promise((resolve, reject) => {
            let retString = '';
            for (let i = 0; i < length; i++) {
                retString += '?,';
            }
            if (retString.length > 1) {
                retString = retString.slice(0, -1);
                resolve(retString);
            }
            else {
                reject('CreateQuestionMarkString: length = 0');
            }
        });
    }
    /**
     * SetNameForUpdate
     * @param names
     */
    async setNameForUpdate(names) {
        let retString = '';
        for (const name of names) {
            retString += `${name} = ? ,`;
        }
        if (retString.length > 1) {
            retString = retString.slice(0, -1);
            return Promise.resolve(retString);
        }
        else {
            return Promise.reject('SetNameForUpdate: length = 0');
        }
    }
    /**
     * IsJsonSQLite
     * @param obj
     */
    isJsonSQLite(obj) {
        const keyFirstLevel = [
            'database',
            'version',
            'overwrite',
            'encrypted',
            'mode',
            'tables',
            'views',
        ];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyFirstLevel.indexOf(key) === -1)
                return false;
            if (key === 'database' && typeof obj[key] != 'string')
                return false;
            if (key === 'version' && typeof obj[key] != 'number')
                return false;
            if (key === 'overwrite' && typeof obj[key] != 'boolean')
                return false;
            if (key === 'encrypted' && typeof obj[key] != 'boolean')
                return false;
            if (key === 'mode' && typeof obj[key] != 'string')
                return false;
            if (key === 'tables' && typeof obj[key] != 'object')
                return false;
            if (key === 'tables') {
                for (const oKey of obj[key]) {
                    const retTable = this.isTable(oKey);
                    if (!retTable)
                        return false;
                }
            }
            if (key === 'views' && typeof obj[key] != 'object')
                return false;
            if (key === 'views') {
                for (const oKey of obj[key]) {
                    const retView = this.isView(oKey);
                    if (!retView)
                        return false;
                }
            }
        }
        return true;
    }
    /**
     * IsTable
     * @param obj
     */
    isTable(obj) {
        const keyTableLevel = [
            'name',
            'schema',
            'indexes',
            'triggers',
            'values',
        ];
        let nbColumn = 0;
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyTableLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'schema' && typeof obj[key] != 'object')
                return false;
            if (key === 'indexes' && typeof obj[key] != 'object')
                return false;
            if (key === 'triggers' && typeof obj[key] != 'object')
                return false;
            if (key === 'values' && typeof obj[key] != 'object')
                return false;
            if (key === 'schema') {
                obj['schema'].forEach((element) => {
                    if (element.column) {
                        nbColumn++;
                    }
                });
                for (let i = 0; i < nbColumn; i++) {
                    const retSchema = this.isSchema(obj[key][i]);
                    if (!retSchema)
                        return false;
                }
            }
            if (key === 'indexes') {
                for (const oKey of obj[key]) {
                    const retIndexes = this.isIndexes(oKey);
                    if (!retIndexes)
                        return false;
                }
            }
            if (key === 'triggers') {
                for (const oKey of obj[key]) {
                    const retTriggers = this.isTriggers(oKey);
                    if (!retTriggers)
                        return false;
                }
            }
            if (key === 'values') {
                if (nbColumn > 0) {
                    for (const oKey of obj[key]) {
                        if (typeof oKey != 'object' || oKey.length != nbColumn)
                            return false;
                    }
                }
            }
        }
        return true;
    }
    /**
     * IsSchema
     * @param obj
     */
    isSchema(obj) {
        const keySchemaLevel = [
            'column',
            'value',
            'foreignkey',
            'primarykey',
            'constraint',
        ];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keySchemaLevel.indexOf(key) === -1)
                return false;
            if (key === 'column' && typeof obj[key] != 'string')
                return false;
            if (key === 'value' && typeof obj[key] != 'string')
                return false;
            if (key === 'foreignkey' && typeof obj[key] != 'string')
                return false;
            if (key === 'primarykey' && typeof obj[key] != 'string')
                return false;
            if (key === 'constraint' && typeof obj[key] != 'string')
                return false;
        }
        return true;
    }
    /**
     * isIndexes
     * @param obj
     */
    isIndexes(obj) {
        const keyIndexesLevel = ['name', 'value', 'mode'];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyIndexesLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'value' && typeof obj[key] != 'string')
                return false;
            if (key === 'mode' &&
                (typeof obj[key] != 'string' || obj[key].toUpperCase() != 'UNIQUE'))
                return false;
        }
        return true;
    }
    /**
     * isTriggers
     * @param obj
     */
    isTriggers(obj) {
        const keyTriggersLevel = [
            'name',
            'timeevent',
            'condition',
            'logic',
        ];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyTriggersLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'timeevent' && typeof obj[key] != 'string')
                return false;
            if (key === 'condition' && typeof obj[key] != 'string')
                return false;
            if (key === 'logic' && typeof obj[key] != 'string')
                return false;
        }
        return true;
    }
    /**
     * IsViews
     * @param obj
     */
    isView(obj) {
        const keyViewLevel = ['name', 'value'];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyViewLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'value' && typeof obj[key] != 'string')
                return false;
        }
        return true;
    }
    /**
     * checkSchemaValidity
     * @param schema
     */
    async checkSchemaValidity(schema) {
        for (let i = 0; i < schema.length; i++) {
            const sch = {};
            const keys = Object.keys(schema[i]);
            if (keys.includes('column')) {
                sch.column = schema[i].column;
            }
            if (keys.includes('value')) {
                sch.value = schema[i].value;
            }
            if (keys.includes('foreignkey')) {
                sch.foreignkey = schema[i].foreignkey;
            }
            if (keys.includes('constraint')) {
                sch.constraint = schema[i].constraint;
            }
            const isValid = this.isSchema(sch);
            if (!isValid) {
                return Promise.reject(`CheckSchemaValidity: schema[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * checkIndexesSchemaValidity
     * @param indexes
     */
    async checkIndexesValidity(indexes) {
        for (let i = 0; i < indexes.length; i++) {
            const index = {};
            const keys = Object.keys(indexes[i]);
            if (keys.includes('value')) {
                index.value = indexes[i].value;
            }
            if (keys.includes('name')) {
                index.name = indexes[i].name;
            }
            if (keys.includes('mode')) {
                index.mode = indexes[i].mode;
            }
            const isValid = this.isIndexes(index);
            if (!isValid) {
                return Promise.reject(`CheckIndexesValidity: indexes[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * checkTriggersValidity
     * @param triggers
     */
    async checkTriggersValidity(triggers) {
        for (let i = 0; i < triggers.length; i++) {
            const trigger = {};
            const keys = Object.keys(triggers[i]);
            if (keys.includes('logic')) {
                trigger.logic = triggers[i].logic;
            }
            if (keys.includes('name')) {
                trigger.name = triggers[i].name;
            }
            if (keys.includes('timeevent')) {
                trigger.timeevent = triggers[i].timeevent;
            }
            if (keys.includes('condition')) {
                trigger.condition = triggers[i].condition;
            }
            const isValid = this.isTriggers(trigger);
            if (!isValid) {
                return Promise.reject(`CheckTriggersValidity: triggers[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * checkViewsValidity
     * @param views
     */
    async checkViewsValidity(views) {
        for (let i = 0; i < views.length; i++) {
            const view = {};
            const keys = Object.keys(views[i]);
            if (keys.includes('value')) {
                view.value = views[i].value;
            }
            if (keys.includes('name')) {
                view.name = views[i].name;
            }
            const isValid = this.isView(view);
            if (!isValid) {
                return Promise.reject(`CheckViewsValidity: views[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * CreateView
     * @param mDB
     * @param table
     */
    async createView(mDB, view) {
        const stmt = `CREATE VIEW IF NOT EXISTS ${view.name} AS ${view.value};`;
        try {
            const changes = await this.sqliteUtil.execute(mDB, stmt, true);
            if (changes < 0) {
                return Promise.reject(`CreateView: ${view.name} failed`);
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`CreateView: ${err}`);
        }
    }
}
utilsJson.UtilsJson = UtilsJson;

Object.defineProperty(exportToJson, "__esModule", { value: true });
exportToJson.ExportToJson = void 0;
const utilsSQLite_1$4 = utilsSQLite;
const utilsJson_1$3 = utilsJson;
class ExportToJson {
    constructor() {
        this.sqliteUtil = new utilsSQLite_1$4.UtilsSQLite();
        this.jsonUtil = new utilsJson_1$3.UtilsJson();
    }
    /**
     * CreateExportObject
     * @param mDB
     * @param sqlObj
     */
    async createExportObject(mDB, sqlObj) {
        const retObj = {};
        let tables = [];
        let views = [];
        let errmsg = '';
        try {
            // get View's name
            views = await this.getViewsName(mDB);
            // get Table's name
            const resTables = await this.getTablesNameSQL(mDB);
            if (resTables.length === 0) {
                return Promise.reject("createExportObject: table's names failed");
            }
            else {
                const isTable = await this.jsonUtil.isTableExists(mDB, true, 'sync_table');
                if (!isTable && sqlObj.mode === 'partial') {
                    return Promise.reject('No sync_table available');
                }
                switch (sqlObj.mode) {
                    case 'partial': {
                        tables = await this.getTablesPartial(mDB, resTables);
                        break;
                    }
                    case 'full': {
                        tables = await this.getTablesFull(mDB, resTables);
                        break;
                    }
                    default: {
                        errmsg =
                            'createExportObject: expMode ' + sqlObj.mode + ' not defined';
                        break;
                    }
                }
                if (errmsg.length > 0) {
                    return Promise.reject(errmsg);
                }
                if (tables.length > 0) {
                    retObj.database = sqlObj.database;
                    retObj.version = sqlObj.version;
                    retObj.encrypted = sqlObj.encrypted;
                    retObj.mode = sqlObj.mode;
                    retObj.tables = tables;
                    if (views.length > 0) {
                        retObj.views = views;
                    }
                }
                return Promise.resolve(retObj);
            }
        }
        catch (err) {
            return Promise.reject('createExportObject: ' + err);
        }
    }
    /**
     * GetTablesNameSQL
     * @param mDb
     */
    async getTablesNameSQL(mDb) {
        let sql = 'SELECT name,sql FROM sqlite_master WHERE ';
        sql += "type='table' AND name NOT LIKE 'sync_table' ";
        sql += "AND name NOT LIKE '_temp_%' ";
        sql += "AND name NOT LIKE 'sqlite_%';";
        let retQuery = [];
        try {
            retQuery = await this.sqliteUtil.queryAll(mDb, sql, []);
            return Promise.resolve(retQuery);
        }
        catch (err) {
            return Promise.reject(`getTablesNameSQL: ${err}`);
        }
    }
    async getLastExportDate(mDb) {
        return new Promise((resolve, reject) => {
            let retDate = -1;
            // get the last sync date
            const stmt = `SELECT sync_date FROM sync_table WHERE id = 2;`;
            mDb.get(stmt, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`getLastExportDate: ${err.message}`);
                }
                else {
                    if (row != null) {
                        const key = Object.keys(row)[0];
                        retDate = row[key];
                    }
                    resolve(retDate);
                }
            });
        });
    }
    /**
     * SetLastExportDate
     * @param mDb
     * @param lastExportedDate
     * @returns
     */
    async setLastExportDate(mDb, lastExportedDate) {
        try {
            const isTable = await this.jsonUtil.isTableExists(mDb, true, 'sync_table');
            if (!isTable) {
                return Promise.reject(new Error('setLastExportDate: No sync_table available'));
            }
            const sDate = Math.round(new Date(lastExportedDate).getTime() / 1000);
            let stmt = '';
            if ((await this.getLastExportDate(mDb)) > 0) {
                stmt = `UPDATE sync_table SET sync_date = ${sDate} WHERE id = 2;`;
            }
            else {
                stmt = `INSERT INTO sync_table (sync_date) VALUES (${sDate});`;
            }
            const changes = await this.sqliteUtil.execute(mDb, stmt, false);
            if (changes < 0) {
                return { result: false, message: 'setLastExportDate failed' };
            }
            else {
                return { result: true };
            }
        }
        catch (err) {
            return {
                result: false,
                message: `setLastExportDate failed: ${err.message}`,
            };
        }
    }
    async delExportedRows(mDb) {
        let lastExportDate;
        try {
            // check if synchronization table exists
            const isTable = await this.jsonUtil.isTableExists(mDb, true, 'sync_table');
            if (!isTable) {
                return Promise.reject('DelExportedRows: No sync_table available');
            }
            // get the last export date
            lastExportDate = await this.getLastExportDate(mDb);
            if (lastExportDate < 0) {
                return Promise.reject('DelExportedRows: no last exported date available');
            }
            // get the table' name list
            const resTables = await this.sqliteUtil.getTablesNames(mDb);
            if (resTables.length === 0) {
                return Promise.reject("DelExportedRows: No table's names returned");
            }
            // Loop through the tables
            for (const table of resTables) {
                let lastId = -1;
                // define the delete statement
                const delStmt = `DELETE FROM ${table}
              WHERE sql_deleted = 1 AND last_modified < ${lastExportDate};`;
                lastId = await this.sqliteUtil.prepareRun(mDb, delStmt, [], true);
                if (lastId < 0) {
                    return Promise.reject('DelExportedRows: lastId < 0');
                }
            }
        }
        catch (err) {
            return Promise.reject(`DelExportedRows failed: ${err.message}`);
        }
    }
    /**
     * GetViewsNameSQL
     * @param mDb
     */
    async getViewsName(mDb) {
        const views = [];
        let sql = 'SELECT name,sql FROM sqlite_master WHERE ';
        sql += "type='view' AND name NOT LIKE 'sqlite_%';";
        let retQuery = [];
        try {
            retQuery = await this.sqliteUtil.queryAll(mDb, sql, []);
            for (const query of retQuery) {
                const view = {};
                view.name = query.name;
                view.value = query.sql.substring(query.sql.indexOf('AS ') + 3);
                views.push(view);
            }
            return Promise.resolve(views);
        }
        catch (err) {
            return Promise.reject(`getViewsName: ${err}`);
        }
    }
    /**
     * GetSyncDate
     * @param mDb
     */
    async getSyncDate(mDb) {
        return new Promise((resolve, reject) => {
            let retDate = -1;
            // get the last sync date
            const stmt = `SELECT sync_date FROM sync_table WHERE id = 1;`;
            mDb.get(stmt, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`GetSyncDate: ${err.message}`);
                }
                else {
                    if (row != null) {
                        const key = Object.keys(row)[0];
                        retDate = row[key];
                        resolve(retDate);
                    }
                    else {
                        reject(`GetSyncDate: no syncDate`);
                    }
                }
            });
        });
    }
    /**
     * GetTablesFull
     * @param mDb
     * @param resTables
     */
    async getTablesFull(mDb, resTables) {
        const tables = [];
        let errmsg = '';
        try {
            // Loop through the tables
            for (const rTable of resTables) {
                let tableName;
                let sqlStmt;
                if (rTable.name) {
                    tableName = rTable.name;
                }
                else {
                    errmsg = 'GetTablesFull: no name';
                    break;
                }
                if (rTable.sql) {
                    sqlStmt = rTable.sql;
                }
                else {
                    errmsg = 'GetTablesFull: no sql';
                    break;
                }
                const table = {};
                // create Table's Schema
                const schema = await this.getSchema(sqlStmt);
                if (schema.length === 0) {
                    errmsg = 'GetTablesFull: no Schema returned';
                    break;
                }
                // check schema validity
                await this.jsonUtil.checkSchemaValidity(schema);
                // create Table's indexes if any
                const indexes = await this.getIndexes(mDb, tableName);
                if (indexes.length > 0) {
                    // check indexes validity
                    await this.jsonUtil.checkIndexesValidity(indexes);
                }
                // create Table's triggers if any
                const triggers = await this.getTriggers(mDb, tableName);
                if (triggers.length > 0) {
                    // check triggers validity
                    await this.jsonUtil.checkTriggersValidity(triggers);
                }
                // create Table's Data
                const query = `SELECT * FROM ${tableName};`;
                const values = await this.jsonUtil.getValues(mDb, query, tableName);
                table.name = tableName;
                if (schema.length > 0) {
                    table.schema = schema;
                }
                else {
                    errmsg = `GetTablesFull: must contain schema`;
                    break;
                }
                if (indexes.length > 0) {
                    table.indexes = indexes;
                }
                if (triggers.length > 0) {
                    table.triggers = triggers;
                }
                if (values.length > 0) {
                    table.values = values;
                }
                if (Object.keys(table).length <= 1) {
                    errmsg = `GetTablesFull: table ${tableName} is not a jsonTable`;
                    break;
                }
                tables.push(table);
            }
            if (errmsg.length > 0) {
                return Promise.reject(errmsg);
            }
            return Promise.resolve(tables);
        }
        catch (err) {
            return Promise.reject(`GetTablesFull: ${err}`);
        }
    }
    /**
     * GetSchema
     * @param mDb
     * @param sqlStmt
     * @param tableName
     */
    async getSchema(sqlStmt /*,tableName: string,*/) {
        const schema = [];
        // take the substring between parenthesis
        const openPar = sqlStmt.indexOf('(');
        const closePar = sqlStmt.lastIndexOf(')');
        let sstr = sqlStmt.substring(openPar + 1, closePar);
        // check if there is other parenthesis and replace the ',' by '§'
        try {
            sstr = await this.modEmbeddedParentheses(sstr);
            const sch = sstr.split(',');
            // for each element of the array split the
            // first word as key
            for (const sc of sch) {
                const row = [];
                const scht = sc.replace(/\n/g, '').trim();
                row[0] = scht.substring(0, scht.indexOf(' '));
                row[1] = scht.substring(scht.indexOf(' ') + 1);
                const jsonRow = {};
                if (row[0].toUpperCase() === 'FOREIGN') {
                    const oPar = scht.indexOf('(');
                    const cPar = scht.indexOf(')');
                    const fk = scht.substring(oPar + 1, cPar);
                    const fknames = fk.split('§');
                    row[0] = fknames.join(',');
                    row[0] = row[0].replace(/, /g, ',');
                    row[1] = scht.substring(cPar + 2);
                    jsonRow['foreignkey'] = row[0];
                }
                else if (row[0].toUpperCase() === 'PRIMARY') {
                    const oPar = scht.indexOf('(');
                    const cPar = scht.indexOf(')');
                    const pk = scht.substring(oPar + 1, cPar);
                    const pknames = pk.split('§');
                    row[0] = 'CPK_' + pknames.join('_');
                    row[0] = row[0].replace(/_ /g, '_');
                    row[1] = scht;
                    jsonRow['constraint'] = row[0];
                }
                else if (row[0].toUpperCase() === 'CONSTRAINT') {
                    const tRow = [];
                    const row1t = row[1].trim();
                    tRow[0] = row1t.substring(0, row1t.indexOf(' '));
                    tRow[1] = row1t.substring(row1t.indexOf(' ') + 1);
                    row[0] = tRow[0];
                    jsonRow['constraint'] = row[0];
                    row[1] = tRow[1];
                }
                else {
                    jsonRow['column'] = row[0];
                }
                jsonRow['value'] = row[1].replace(/§/g, ',');
                schema.push(jsonRow);
            }
            return Promise.resolve(schema);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    /**
     * GetIndexes
     * @param mDb
     * @param sqlStmt
     * @param tableName
     */
    async getIndexes(mDb, tableName) {
        const indexes = [];
        let errmsg = '';
        try {
            let stmt = 'SELECT name,tbl_name,sql FROM sqlite_master WHERE ';
            stmt += `type = 'index' AND tbl_name = '${tableName}' `;
            stmt += `AND sql NOTNULL;`;
            const retIndexes = await this.sqliteUtil.queryAll(mDb, stmt, []);
            if (retIndexes.length > 0) {
                for (const rIndex of retIndexes) {
                    const keys = Object.keys(rIndex);
                    if (keys.length === 3) {
                        if (rIndex['tbl_name'] === tableName) {
                            const sql = rIndex['sql'];
                            const mode = sql.includes('UNIQUE') ? 'UNIQUE' : '';
                            const oPar = sql.lastIndexOf('(');
                            const cPar = sql.lastIndexOf(')');
                            const index = {};
                            index.name = rIndex['name'];
                            index.value = sql.slice(oPar + 1, cPar);
                            if (mode.length > 0)
                                index.mode = mode;
                            indexes.push(index);
                        }
                        else {
                            errmsg = `GetIndexes: Table ${tableName} doesn't match`;
                            break;
                        }
                    }
                    else {
                        errmsg = `GetIndexes: Table ${tableName} creating indexes`;
                        break;
                    }
                }
                if (errmsg.length > 0) {
                    return Promise.reject(errmsg);
                }
            }
            return Promise.resolve(indexes);
        }
        catch (err) {
            return Promise.reject(`GetIndexes: ${err}`);
        }
    }
    /**
     * GetTriggers
     * @param mDb
     * @param sqlStmt
     * @param tableName
     */
    async getTriggers(mDb, tableName) {
        const triggers = [];
        try {
            let stmt = 'SELECT name,tbl_name,sql FROM sqlite_master WHERE ';
            stmt += `type = 'trigger' AND tbl_name = '${tableName}' `;
            stmt += `AND sql NOT NULL;`;
            const retTriggers = await this.sqliteUtil.queryAll(mDb, stmt, []);
            if (retTriggers.length > 0) {
                for (const rTrg of retTriggers) {
                    const keys = Object.keys(rTrg);
                    if (keys.length === 3) {
                        if (rTrg['tbl_name'] === tableName) {
                            const sql = rTrg['sql'];
                            const name = rTrg['name'];
                            let sqlArr = sql.split(name);
                            if (sqlArr.length != 2) {
                                return Promise.reject(`GetTriggers: sql split name does not return 2 values`);
                            }
                            if (!sqlArr[1].includes(tableName)) {
                                return Promise.reject(`GetTriggers: sql split does not contains ${tableName}`);
                            }
                            const timeEvent = sqlArr[1].split(tableName, 1)[0].trim();
                            sqlArr = sqlArr[1].split(timeEvent + ' ' + tableName);
                            if (sqlArr.length != 2) {
                                return Promise.reject(`GetTriggers: sql split tableName does not return 2 values`);
                            }
                            let condition = '';
                            let logic = '';
                            if (sqlArr[1].trim().substring(0, 5).toUpperCase() !== 'BEGIN') {
                                sqlArr = sqlArr[1].trim().split('BEGIN');
                                if (sqlArr.length != 2) {
                                    return Promise.reject(`GetTriggers: sql split BEGIN does not return 2 values`);
                                }
                                condition = sqlArr[0].trim();
                                logic = 'BEGIN' + sqlArr[1];
                            }
                            else {
                                logic = sqlArr[1].trim();
                            }
                            const trigger = {};
                            trigger.name = name;
                            trigger.logic = logic;
                            if (condition.length > 0)
                                trigger.condition = condition;
                            trigger.timeevent = timeEvent;
                            triggers.push(trigger);
                        }
                        else {
                            return Promise.reject(`GetTriggers: Table ${tableName} doesn't match`);
                        }
                    }
                    else {
                        return Promise.reject(`GetTriggers: Table ${tableName} creating indexes`);
                    }
                }
            }
            return Promise.resolve(triggers);
        }
        catch (err) {
            return Promise.reject(`GetTriggers: ${err}`);
        }
    }
    /**
     * GetTablesPartial
     * @param mDb
     * @param resTables
     */
    async getTablesPartial(mDb, resTables) {
        const tables = [];
        let modTables = {};
        let syncDate = 0;
        let modTablesKeys = [];
        let errmsg = '';
        try {
            // Get the syncDate and the Modified Tables
            const partialModeData = await this.getPartialModeData(mDb, resTables);
            if (Object.keys(partialModeData).includes('syncDate')) {
                syncDate = partialModeData.syncDate;
            }
            if (Object.keys(partialModeData).includes('modTables')) {
                modTables = partialModeData.modTables;
                modTablesKeys = Object.keys(modTables);
            }
            // Loop trough tables
            for (const rTable of resTables) {
                let tableName = '';
                let sqlStmt = '';
                if (rTable.name) {
                    tableName = rTable.name;
                }
                else {
                    errmsg = 'GetTablesFull: no name';
                    break;
                }
                if (rTable.sql) {
                    sqlStmt = rTable.sql;
                }
                else {
                    errmsg = 'GetTablesFull: no sql';
                    break;
                }
                if (modTablesKeys.length == 0 ||
                    modTablesKeys.indexOf(tableName) === -1 ||
                    modTables[tableName] == 'No') {
                    continue;
                }
                const table = {};
                let schema = [];
                let indexes = [];
                let triggers = [];
                table.name = rTable;
                if (modTables[table.name] === 'Create') {
                    // create Table's Schema
                    schema = await this.getSchema(sqlStmt);
                    if (schema.length > 0) {
                        // check schema validity
                        await this.jsonUtil.checkSchemaValidity(schema);
                    }
                    // create Table's indexes if any
                    indexes = await this.getIndexes(mDb, tableName);
                    if (indexes.length > 0) {
                        // check indexes validity
                        await this.jsonUtil.checkIndexesValidity(indexes);
                    }
                    // create Table's triggers if any
                    triggers = await this.getTriggers(mDb, tableName);
                    if (triggers.length > 0) {
                        // check triggers validity
                        await this.jsonUtil.checkTriggersValidity(triggers);
                    }
                }
                // create Table's Data
                let query = '';
                if (modTables[tableName] === 'Create') {
                    query = `SELECT * FROM ${tableName};`;
                }
                else {
                    query =
                        `SELECT * FROM ${tableName} ` +
                            `WHERE last_modified > ${syncDate};`;
                }
                const values = await this.jsonUtil.getValues(mDb, query, tableName);
                // check the table object validity
                table.name = tableName;
                if (schema.length > 0) {
                    table.schema = schema;
                }
                if (indexes.length > 0) {
                    table.indexes = indexes;
                }
                if (triggers.length > 0) {
                    table.triggers = triggers;
                }
                if (values.length > 0) {
                    table.values = values;
                }
                if (Object.keys(table).length <= 1) {
                    errmsg = `GetTablesPartial: table ${tableName} is not a jsonTable`;
                    break;
                }
                tables.push(table);
            }
            if (errmsg.length > 0) {
                return Promise.reject(errmsg);
            }
            return Promise.resolve(tables);
        }
        catch (err) {
            return Promise.reject(`GetTablesPartial: ${err}`);
        }
    }
    /**
     * GetPartialModeData
     * @param mDb
     * @param resTables
     */
    async getPartialModeData(mDb, resTables) {
        const retData = {};
        try {
            // get the synchronization date
            const syncDate = await this.getSyncDate(mDb);
            if (syncDate <= 0) {
                return Promise.reject(`GetPartialModeData: no syncDate`);
            }
            // get the tables which have been updated
            // since last synchronization
            const modTables = await this.getTablesModified(mDb, resTables, syncDate);
            if (modTables.length <= 0) {
                return Promise.reject(`GetPartialModeData: no modTables`);
            }
            retData.syncDate = syncDate;
            retData.modTables = modTables;
            return Promise.resolve(retData);
        }
        catch (err) {
            return Promise.reject(`GetPartialModeData: ${err}`);
        }
    }
    async getTablesModified(db, tables, syncDate) {
        let errmsg = '';
        try {
            const retModified = {};
            for (const rTable of tables) {
                let mode;
                // get total count of the table
                let stmt = 'SELECT count(*) AS tcount  ';
                stmt += `FROM ${rTable.name};`;
                let retQuery = await this.sqliteUtil.queryAll(db, stmt, []);
                if (retQuery.length != 1) {
                    errmsg = 'GetTableModified: total ' + 'count not returned';
                    break;
                }
                const totalCount = retQuery[0]['tcount'];
                // get total count of modified since last sync
                stmt = 'SELECT count(*) AS mcount FROM ';
                stmt += `${rTable.name} WHERE last_modified > `;
                stmt += `${syncDate};`;
                retQuery = await this.sqliteUtil.queryAll(db, stmt, []);
                if (retQuery.length != 1)
                    break;
                const totalModifiedCount = retQuery[0]['mcount'];
                if (totalModifiedCount === 0) {
                    mode = 'No';
                }
                else if (totalCount === totalModifiedCount) {
                    mode = 'Create';
                }
                else {
                    mode = 'Modified';
                }
                const key = rTable.name;
                retModified[key] = mode;
            }
            if (errmsg.length > 0) {
                return Promise.reject(errmsg);
            }
            return Promise.resolve(retModified);
        }
        catch (err) {
            return Promise.reject(`GetTableModified: ${err}`);
        }
    }
    async modEmbeddedParentheses(sstr) {
        const oParArray = this.indexOfChar(sstr, '(');
        const cParArray = this.indexOfChar(sstr, ')');
        if (oParArray.length != cParArray.length) {
            return Promise.reject("ModEmbeddedParentheses: Not same number of '(' & ')'");
        }
        if (oParArray.length === 0) {
            return Promise.resolve(sstr);
        }
        let resStmt = sstr.substring(0, oParArray[0] - 1);
        for (let i = 0; i < oParArray.length; i++) {
            let str;
            if (i < oParArray.length - 1) {
                if (oParArray[i + 1] < cParArray[i]) {
                    str = sstr.substring(oParArray[i] - 1, cParArray[i + 1]);
                    i++;
                }
                else {
                    str = sstr.substring(oParArray[i] - 1, cParArray[i]);
                }
            }
            else {
                str = sstr.substring(oParArray[i] - 1, cParArray[i]);
            }
            const newS = str.replace(/,/g, '§');
            resStmt += newS;
            if (i < oParArray.length - 1) {
                resStmt += sstr.substring(cParArray[i], oParArray[i + 1] - 1);
            }
        }
        resStmt += sstr.substring(cParArray[cParArray.length - 1], sstr.length);
        return Promise.resolve(resStmt);
    }
    indexOfChar(str, char) {
        const tmpArr = [...str];
        char = char.toLowerCase();
        return tmpArr.reduce((results, elem, idx) => elem.toLowerCase() === char ? [...results, idx] : results, []);
    }
}
exportToJson.ExportToJson = ExportToJson;

var importFromJson = {};

var utilsDrop = {};

Object.defineProperty(utilsDrop, "__esModule", { value: true });
utilsDrop.UtilsDrop = void 0;
const utilsSQLite_1$3 = utilsSQLite;
class UtilsDrop {
    constructor() {
        this.sqliteUtil = new utilsSQLite_1$3.UtilsSQLite();
    }
    /**
     * DropElements
     * @param db
     * @param type ["table","index","trigger"]
     */
    async dropElements(db, type) {
        let msg = '';
        let stmt1 = `AND name NOT LIKE ('sqlite_%')`;
        switch (type) {
            case 'index':
                msg = 'DropIndexes';
                break;
            case 'trigger':
                msg = 'DropTriggers';
                break;
            case 'table':
                msg = 'DropTables';
                stmt1 += ` AND name NOT IN ('sync_table')`;
                break;
            case 'view':
                msg = 'DropViews';
                break;
            default:
                return Promise.reject(`DropElements: ${type} ` + 'not found');
        }
        // get the element's names
        let stmt = 'SELECT name FROM sqlite_master WHERE ';
        stmt += `type = '${type}' ${stmt1};`;
        try {
            const elements = await this.sqliteUtil.queryAll(db, stmt, []);
            if (elements.length > 0) {
                const upType = type.toUpperCase();
                const statements = [];
                for (const elem of elements) {
                    let stmt = `DROP ${upType} IF EXISTS `;
                    stmt += `${elem.name};`;
                    statements.push(stmt);
                }
                for (const stmt of statements) {
                    const lastId = await this.sqliteUtil.prepareRun(db, stmt, [], false);
                    if (lastId < 0) {
                        return Promise.reject(`${msg}: lastId < 0`);
                    }
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`${msg}: ${err}`);
        }
    }
    /**
     * DropAll
     * Drop all database's elements
     * @param db
     */
    async dropAll(db) {
        try {
            // drop tables
            await this.dropElements(db, 'table');
            // drop indexes
            await this.dropElements(db, 'index');
            // drop triggers
            await this.dropElements(db, 'trigger');
            // drop views
            await this.dropElements(db, 'view');
            // vacuum the database
            await this.sqliteUtil.prepareRun(db, 'VACUUM;', [], false);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`DropAll: ${err}`);
        }
    }
    /**
     * DropTempTables
     * @param db
     * @param alterTables
     */
    async dropTempTables(db, alterTables) {
        const tempTables = Object.keys(alterTables);
        const statements = [];
        for (const tTable of tempTables) {
            let stmt = 'DROP TABLE IF EXISTS ';
            stmt += `_temp_${tTable};`;
            statements.push(stmt);
        }
        try {
            const changes = await this.sqliteUtil.execute(db, statements.join('\n'), false);
            if (changes < 0) {
                return Promise.reject('DropTempTables: changes < 0');
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`DropTempTables: ${err}`);
        }
    }
}
utilsDrop.UtilsDrop = UtilsDrop;

Object.defineProperty(importFromJson, "__esModule", { value: true });
importFromJson.ImportFromJson = void 0;
const utilsDrop_1 = utilsDrop;
const utilsSQLite_1$2 = utilsSQLite;
const utilsJson_1$2 = utilsJson;
class ImportFromJson {
    constructor() {
        this.jsonUtil = new utilsJson_1$2.UtilsJson();
        this.sqliteUtil = new utilsSQLite_1$2.UtilsSQLite();
        this.dropUtil = new utilsDrop_1.UtilsDrop();
    }
    /**
     * CreateDatabaseSchema
     * @param mDB
     * @param jsonData
     */
    async createDatabaseSchema(mDB, jsonData) {
        let changes = -1;
        const version = jsonData.version;
        try {
            // set User Version PRAGMA
            await this.sqliteUtil.setVersion(mDB, version);
            // DROP ALL when mode="full"
            if (jsonData.mode === 'full') {
                await this.dropUtil.dropAll(mDB);
            }
            // create database schema
            changes = await this.jsonUtil.createSchema(mDB, jsonData);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject('CreateDatabaseSchema: ' + `${err}`);
        }
    }
    async createTablesData(mDB, jsonData) {
        let changes = 0;
        let isValue = false;
        let lastId = -1;
        let msg = '';
        let initChanges = -1;
        try {
            initChanges = await this.sqliteUtil.dbChanges(mDB);
            // start a transaction
            await this.sqliteUtil.beginTransaction(mDB, true);
        }
        catch (err) {
            return Promise.reject(`createTablesData: ${err}`);
        }
        for (const jTable of jsonData.tables) {
            if (jTable.values != null && jTable.values.length >= 1) {
                // Create the table's data
                try {
                    lastId = await this.jsonUtil.createDataTable(mDB, jTable, jsonData.mode);
                    if (lastId < 0)
                        break;
                    isValue = true;
                }
                catch (err) {
                    msg = err;
                    isValue = false;
                    break;
                }
            }
        }
        if (isValue) {
            try {
                await this.sqliteUtil.commitTransaction(mDB, true);
                changes = (await this.sqliteUtil.dbChanges(mDB)) - initChanges;
                return Promise.resolve(changes);
            }
            catch (err) {
                return Promise.reject('createTablesData: ' + `${err}`);
            }
        }
        else {
            if (msg.length > 0) {
                try {
                    await this.sqliteUtil.rollbackTransaction(mDB, true);
                    return Promise.reject(new Error(`createTablesData: ${msg}`));
                }
                catch (err) {
                    return Promise.reject('createTablesData: ' + `${err}: ${msg}`);
                }
            }
            else {
                // case were no values given
                return Promise.resolve(0);
            }
        }
    }
    /**
     * CreateViews
     * @param mDB
     * @param jsonData
     */
    async createViews(mDB, jsonData) {
        let isView = false;
        let msg = '';
        let initChanges = -1;
        let changes = -1;
        try {
            initChanges = await this.sqliteUtil.dbChanges(mDB);
            // start a transaction
            await this.sqliteUtil.beginTransaction(mDB, true);
        }
        catch (err) {
            return Promise.reject(`createViews: ${err}`);
        }
        for (const jView of jsonData.views) {
            if (jView.value != null) {
                // Create the view
                try {
                    await this.jsonUtil.createView(mDB, jView);
                    isView = true;
                }
                catch (err) {
                    msg = err;
                    isView = false;
                    break;
                }
            }
        }
        if (isView) {
            try {
                await this.sqliteUtil.commitTransaction(mDB, true);
                changes = (await this.sqliteUtil.dbChanges(mDB)) - initChanges;
                return Promise.resolve(changes);
            }
            catch (err) {
                return Promise.reject('createViews: ' + `${err}`);
            }
        }
        else {
            if (msg.length > 0) {
                try {
                    await this.sqliteUtil.rollbackTransaction(mDB, true);
                    return Promise.reject(new Error(`createViews: ${msg}`));
                }
                catch (err) {
                    return Promise.reject('createViews: ' + `${err}: ${msg}`);
                }
            }
            else {
                // case were no views given
                return Promise.resolve(0);
            }
        }
    }
}
importFromJson.ImportFromJson = ImportFromJson;

var utilsFile = {};

Object.defineProperty(utilsFile, "__esModule", { value: true });
utilsFile.UtilsFile = void 0;
const promises_1 = require$$0__default$1["default"];
class UtilsFile {
    constructor() {
        this.pathDB = 'Databases';
        this.Path = null;
        this.NodeFs = null;
        this.NodeFetch = null;
        this.JSZip = null;
        this.Os = null;
        this.Electron = null;
        this.AppName = '';
        this.HomeDir = '';
        this.sep = '/';
        this.Path = require$$1__default["default"];
        this.NodeFs = require$$2__default["default"];
        this.NodeFetch = require$$3__default["default"];
        this.Os = require$$4__default["default"];
        this.JSZip = require$$5__default["default"];
        this.Electron = require$$6__default["default"];
        this.HomeDir = this.Os.homedir();
        const dir = __dirname;
        const idx = dir.indexOf('\\');
        if (idx != -1)
            this.sep = '\\';
        this.appPath = this.Electron.app.getAppPath();
        const rawdata = this.NodeFs.readFileSync(this.Path.resolve(this.appPath, 'package.json'));
        this.AppName = JSON.parse(rawdata).name;
        const pathToBuild = this.Path.join(this.appPath, 'build');
        if (this.NodeFs.existsSync(this.Path.join(pathToBuild, 'capacitor.config.js'))) {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            this.capConfig = require(this.Path.join(pathToBuild, 'capacitor.config.js')).default;
        }
        else {
            this.capConfig = JSON.parse(this.NodeFs.readFileSync(this.Path.join(this.appPath, 'capacitor.config.json')).toString());
        }
        this.osType = this.Os.type();
        switch (this.osType) {
            case 'Darwin':
                this.pathDB =
                    this.capConfig.plugins.CapacitorSQLite.electronMacLocation;
                break;
            case 'Linux':
                this.pathDB =
                    this.capConfig.plugins.CapacitorSQLite.electronLinuxLocation;
                break;
            case 'Windows_NT':
                this.pathDB =
                    this.capConfig.plugins.CapacitorSQLite.electronWindowsLocation;
                break;
            default:
                console.log('other operating system');
        }
        console.log(`&&& Databases path: ${this.pathDB}`);
    }
    /**
     * GetExtName
     * @param filePath
     * @returns
     */
    getExtName(filePath) {
        return this.Path.extname(filePath);
    }
    getBaseName(filePath) {
        return this.Path.basename(filePath, this.Path.extname(filePath));
    }
    /**
     * IsPathExists
     * @param filePath
     */
    isPathExists(filePath) {
        let ret = false;
        try {
            if (this.NodeFs.existsSync(filePath)) {
                ret = true;
            }
        }
        catch (err) {
            console.error('Error isFileExist: ' + err);
            ret = false;
        }
        return ret;
    }
    /**
     * IsFileExists
     * @param fileName
     */
    isFileExists(fileName) {
        let ret = false;
        const filePath = this.getFilePath(fileName);
        if (filePath.length > 0) {
            ret = this.isPathExists(filePath);
        }
        return ret;
    }
    /**
     * GetFilePath
     * get the file path
     * @param fileName
     */
    getFilePath(fileName) {
        return this.Path.join(this.getDatabasesPath(), fileName);
    }
    /**
     * GetDatabasesPath
     * get the database folder path
     */
    getDatabasesPath() {
        let retPath = '';
        const sep = this.Path.sep;
        const dbFolder = this.pathDB;
        if (dbFolder.includes(sep)) {
            retPath = dbFolder;
            if (this.Path.basename(dbFolder) !== this.AppName) {
                retPath = this.Path.join(dbFolder, this.AppName);
            }
        }
        else {
            retPath = this.Path.join(this.HomeDir, dbFolder, this.AppName);
        }
        const retB = this._createFolderIfNotExists(retPath);
        if (!retB)
            retPath = '';
        return retPath;
    }
    /**
     * GetCachePath
     * get the database cache folder path
     */
    getCachePath() {
        let retPath = '';
        const databasePath = this.getDatabasesPath();
        retPath = this.Path.join(databasePath, 'cache');
        const retB = this._createFolderIfNotExists(retPath);
        if (!retB)
            retPath = '';
        return retPath;
    }
    /**
     * GetAssetsDatabasesPath
     * get the assets databases folder path
     */
    getAssetsDatabasesPath() {
        let retPath = '';
        const webDir = this.capConfig.webDir;
        const dir = webDir === 'www' ? 'src' : 'public';
        let mAppPath = this.appPath;
        if (this.Path.basename(this.appPath) === 'electron') {
            mAppPath = this.Path.dirname(this.appPath);
        }
        retPath = this.Path.resolve(mAppPath, dir, 'assets', 'databases');
        return retPath;
    }
    /**
     * SetPathSuffix
     * @param db
     */
    setPathSuffix(db) {
        let toDb = db;
        const ext = '.db';
        const dirName = this.Path.dirname(db);
        const baseName = this.getBaseName(db);
        if (this.getExtName(db) === ext) {
            if (!baseName.includes('SQLite')) {
                const dbName = `${baseName}SQLite`;
                toDb = `${this.Path.join(dirName, dbName)}${ext}`;
            }
        }
        return toDb;
    }
    /**
     * GetFileList
     * get the file list for a given folder
     * @param path
     */
    async getFileList(path) {
        const filenames = this.NodeFs.readdirSync(path);
        const dbs = [];
        filenames.forEach((file) => {
            if (this.getExtName(file) == '.db' || this.getExtName(file) == '.zip')
                dbs.push(file);
        });
        return Promise.resolve(dbs);
    }
    /**
     * CopyFromAssetToDatabase
     * @param db
     * @param overwrite
     */
    async copyFromAssetToDatabase(db, overwrite) {
        const pAsset = this.Path.join(this.getAssetsDatabasesPath(), db);
        const toDb = this.setPathSuffix(db);
        const pDb = this.Path.join(this.getDatabasesPath(), toDb);
        await this.copyFilePath(pAsset, pDb, overwrite);
        return Promise.resolve();
    }
    /**
     * unzipDatabase
     * @param db
     * @param overwrite
     */
    async unzipDatabase(db, fPath, overwrite) {
        const pZip = this.Path.join(fPath, db);
        // Read the Zip file
        this.NodeFs.readFile(pZip, (err, data) => {
            if (err) {
                console.log(err);
                return Promise.reject(`unzipDatabase ${JSON.stringify(err)}`);
            }
            const zip = new this.JSZip();
            zip.loadAsync(data).then((contents) => {
                Object.keys(contents.files).forEach(filename => {
                    zip
                        .file(filename)
                        .async('nodebuffer')
                        .then(async (content) => {
                        const toDb = this.setPathSuffix(filename);
                        const pDb = this.Path.join(this.getDatabasesPath(), toDb);
                        // check filePath exists
                        const isPath = this.isPathExists(pDb);
                        if (!isPath || overwrite) {
                            if (overwrite && isPath) {
                                await this.deleteFilePath(pDb);
                            }
                            this.NodeFs.writeFileSync(pDb, content);
                        }
                        return Promise.resolve();
                    });
                });
            });
        });
    }
    /**
     * CopyFileName
     * Copy file name
     * @param fileName
     * @param toFileName
     */
    async copyFileName(fileName, toFileName) {
        // get File Paths
        const filePath = this.getFilePath(fileName);
        const toFilePath = this.getFilePath(toFileName);
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            try {
                await this.copyFilePath(filePath, toFilePath, true);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(`CopyFileName: ${err}`);
            }
        }
        else {
            return Promise.reject('CopyFileName: cannot get the ' + 'filePath');
        }
    }
    /**
     * CopyFilePath
     * Copy file Path
     * @param filePath
     * @param toFilePath
     */
    async copyFilePath(filePath, toFilePath, overwrite) {
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            // check filePath exists
            const isPath = this.isPathExists(toFilePath);
            if (!isPath || overwrite) {
                try {
                    if (overwrite && isPath) {
                        await this.deleteFilePath(toFilePath);
                    }
                    this.NodeFs.copyFileSync(filePath, toFilePath);
                }
                catch (err) {
                    return Promise.reject(`CopyFilePath: ${err}`);
                }
            }
            return Promise.resolve();
        }
        else {
            return Promise.reject('CopyFilePath: cannot get the ' + 'filePath');
        }
    }
    async copyFile(fromPath, fromFile, toPath, toFile) {
        const fPath = this.Path.join(fromPath, fromFile);
        const tPath = this.Path.join(toPath, toFile);
        try {
            this.NodeFs.copyFileSync(fPath, tPath);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`CopyFile: ${err}`);
        }
    }
    /**
     * DeleteFileName
     * Delete a file by its name
     * @param fileName
     */
    async deleteFileName(fileName) {
        // get file path
        const filePath = this.getFilePath(fileName);
        if (filePath.length !== 0) {
            try {
                await this.deleteFilePath(filePath);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject('DeleteFileName: delete filePath ' + `failed ${err}`);
            }
        }
        else {
            return Promise.reject('DeleteFileName: get filePath ' + 'failed');
        }
    }
    /**
     * DeleteFilePath
     * Delete a file by its path
     * @param filePath
     */
    async deleteFilePath(filePath) {
        let unlinkRetries = 50000;
        /**
         * On windows, the file lock behaves unpredictable. Often it claims a databsae file is locked / busy, although
         * the file stream is already closed.
         * Even though we already checked the status with the `waitForFilePathLock()` method previously.
         *
         * The only way to handle this reliably is to retry deletion until it works.
         */
        const deleteFile = async () => {
            try {
                await promises_1.unlink(filePath);
            }
            catch (err) {
                unlinkRetries--;
                if (unlinkRetries > 0) {
                    await deleteFile();
                }
                else {
                    throw err;
                }
            }
        };
        if (filePath.length !== 0) {
            // check if path exists
            const isPath = this.isPathExists(filePath);
            if (isPath) {
                try {
                    await this.waitForFilePathLock(filePath);
                    // actually delete the file
                    await deleteFile();
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject(`DeleteFilePath: ${err}`);
                }
            }
            else {
                return Promise.resolve();
            }
        }
        else {
            return Promise.reject('DeleteFilePath: delete filePath' + 'failed');
        }
    }
    async waitForFilePathLock(filePath, timeoutMS = 4000) {
        let timeIsOver = false;
        setTimeout(() => {
            timeIsOver = true;
        }, timeoutMS);
        return new Promise((resolve, reject) => {
            const check = async () => {
                if (timeIsOver) {
                    reject(new Error(`WaitForFilePathLock: The resource is still locked / busy after ${timeoutMS} milliseconds.`));
                    return;
                }
                // check if path exists
                const isPath = this.isPathExists(filePath);
                // The file path does not exist. A non existant path cannot be locked.
                if (!isPath) {
                    resolve();
                    return;
                }
                try {
                    const stream = await promises_1.open(filePath, 'r+');
                    // We need to close the stream afterwards, because otherwise, we're locking the file
                    await stream.close();
                    resolve();
                }
                catch (err) {
                    if (err.code === 'EBUSY') {
                        // The resource is busy. Retry in 100ms
                        setTimeout(() => {
                            check();
                        }, 100);
                        return;
                    }
                    else if (err.code === 'ENOENT') {
                        // The file does not exist (anymore). So it cannot be locked.
                        resolve();
                        return;
                    }
                    else {
                        // Something else went wrong.
                        reject(new Error(`WaitForFilePathLock: Error while checking the file: ${err}`));
                    }
                }
            };
            check();
        });
    }
    /**
     * RenameFileName
     * @param fileName
     * @param toFileName
     */
    async renameFileName(fileName, toFileName) {
        // get File Paths
        const filePath = this.getFilePath(fileName);
        const toFilePath = this.getFilePath(toFileName);
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            try {
                await this.renameFilePath(filePath, toFilePath);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(`RenameFileName: ${err}`);
            }
        }
        else {
            return Promise.reject('RenameFileName: filePaths do not ' + 'exist');
        }
    }
    /**
     * RenameFilePath
     * @param filePath
     * @param toFilePath
     */
    async renameFilePath(filePath, toFilePath) {
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            // check filePath exists
            const isPath = this.isPathExists(filePath);
            if (isPath) {
                // delete toFilePath if exists
                try {
                    await this.deleteFilePath(toFilePath);
                    this.NodeFs.renameSync(filePath, toFilePath);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('RenameFilePath: ' + `${err}`);
                }
            }
            else {
                return Promise.reject(`RenameFilePath: ${filePath} does not exist`);
            }
        }
        else {
            return Promise.reject('RenameFilePath: filePath not found');
        }
    }
    async moveDatabaseFromCache() {
        const cachePath = this.getCachePath();
        const databasePath = this.getDatabasesPath();
        const dbCacheList = await this.getFileList(cachePath);
        for (const name of dbCacheList) {
            const ext = this.getExtName(name);
            const fromDBName = this.Path.join(cachePath, name);
            if (ext === '.db') {
                const pDb = this.setPathSuffix(this.Path.join(databasePath, name));
                try {
                    await this.renameFilePath(fromDBName, pDb);
                }
                catch (err) {
                    return Promise.reject('moveDatabaseFromCache: ' + `${err}`);
                }
            }
            if (ext === '.zip') {
                try {
                    await this.deleteFilePath(fromDBName);
                }
                catch (err) {
                    return Promise.reject('moveDatabaseFromCache: ' + `${err}`);
                }
            }
        }
    }
    /**
     * RestoreFileName
     * @param fileName
     * @param prefix
     */
    async restoreFileName(fileName, prefix) {
        const mFileName = `${prefix}-${fileName}`;
        // check if file exists
        const isFilePre = this.isFileExists(mFileName);
        if (isFilePre) {
            const isFile = this.isFileExists(fileName);
            if (isFile) {
                try {
                    await this.deleteFileName(fileName);
                    await this.renameFileName(mFileName, fileName);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('RestoreFileName: ' + `${err}`);
                }
            }
            else {
                return Promise.reject(`RestoreFileName: ${fileName} ` + 'does not exist');
            }
        }
        else {
            return Promise.reject(`RestoreFileName: ${mFileName} ` + 'does not exist');
        }
    }
    /**
     * DownloadFileFromHTTP
     * @param url
     * @param path
     */
    async downloadFileFromHTTP(url, pathFolder) {
        const res = await this.NodeFetch(url);
        const ext = this.getExtName(url);
        const dbName = this.getBaseName(url);
        const filePath = `${this.Path.join(pathFolder, dbName)}${ext}`;
        const fileStream = this.NodeFs.createWriteStream(filePath);
        await new Promise((resolve, reject) => {
            res.body.pipe(fileStream);
            res.body.on('error', reject);
            fileStream.on('finish', resolve);
        });
    }
    /**
     * CreateFolderIfNotExists
     * Create directory
     * @param folder
     */
    _createFolderIfNotExists(folder) {
        let ret;
        try {
            if (!this.NodeFs.existsSync(folder)) {
                this._mkdirSyncRecursive(folder);
            }
            ret = true;
        }
        catch (e) {
            console.log('Error: in getDBPath', e);
            ret = false;
        }
        return ret;
    }
    /**
     * MkdirSyncRecursive
     * Create directories recursively
     * @param directory
     */
    _mkdirSyncRecursive(directory) {
        const sep = this.Path.sep;
        const path = directory.replace(/\/$/, '').split(sep);
        for (let i = 1; i <= path.length; i++) {
            const segment = path.slice(0, i).join(sep);
            segment.length > 0 && !this.NodeFs.existsSync(segment)
                ? this.NodeFs.mkdirSync(segment)
                : null;
        }
        return;
    }
}
utilsFile.UtilsFile = UtilsFile;

var utilsUpgrade = {};

Object.defineProperty(utilsUpgrade, "__esModule", { value: true });
utilsUpgrade.UtilsUpgrade = void 0;
const utilsSQLite_1$1 = utilsSQLite;
class UtilsUpgrade {
    constructor() {
        this.sqliteUtil = new utilsSQLite_1$1.UtilsSQLite();
    }
    /**
     * OnUpgrade
     * @param mDB
     * @param vUpgDict
     * @param dbName
     * @param curVersion
     * @param targetVersion
     */
    async onUpgrade(mDB, vUpgDict, curVersion, targetVersion) {
        let changes;
        const sortedKeys = new Int32Array(Object.keys(vUpgDict).map(item => parseInt(item))).sort();
        console.log(`@@@ sortedKeys: ${sortedKeys}`);
        for (const versionKey of sortedKeys) {
            if (versionKey > curVersion && versionKey <= targetVersion) {
                const statements = vUpgDict[versionKey].statements;
                if (statements.length === 0) {
                    return Promise.reject('onUpgrade: statements not given');
                }
                try {
                    // set Foreign Keys Off
                    await this.sqliteUtil.setForeignKeyConstraintsEnabled(mDB, false);
                    const initChanges = await this.sqliteUtil.dbChanges(mDB);
                    await this.executeStatementsProcess(mDB, statements);
                    await this.sqliteUtil.setVersion(mDB, versionKey);
                    // set Foreign Keys On
                    await this.sqliteUtil.setForeignKeyConstraintsEnabled(mDB, true);
                    changes = (await this.sqliteUtil.dbChanges(mDB)) - initChanges;
                }
                catch (err) {
                    console.log(`@@@@ onUpgrade: ${err}`);
                    return Promise.reject(`onUpgrade: ${err}`);
                }
            }
        }
        return Promise.resolve(changes);
    }
    /**
     * ExecuteStatementProcess
     * @param mDB
     * @param statements
     */
    async executeStatementsProcess(mDB, statements) {
        try {
            await this.sqliteUtil.beginTransaction(mDB, true);
            for (const statement of statements) {
                console.log(`@@@ statement: ${statement}`);
                await this.sqliteUtil.execute(mDB, statement, false);
            }
            await this.sqliteUtil.commitTransaction(mDB, true);
            return Promise.resolve();
        }
        catch (err) {
            await this.sqliteUtil.rollbackTransaction(mDB, true);
            console.log(`@@@ ExecuteStatementProcess: ${err}`);
            return Promise.reject(`ExecuteStatementProcess: ${err}`);
        }
    }
}
utilsUpgrade.UtilsUpgrade = UtilsUpgrade;

Object.defineProperty(Database$1, "__esModule", { value: true });
Database$1.Database = void 0;
const exportToJson_1 = exportToJson;
const importFromJson_1 = importFromJson;
const utilsJson_1$1 = utilsJson;
//import { UtilsEncryption } from './utilsEncryption';
const utilsFile_1$1 = utilsFile;
const utilsSQLite_1 = utilsSQLite;
const utilsUpgrade_1 = utilsUpgrade;
class Database {
    constructor(dbName, 
    //    encrypted: boolean,
    //    mode: string,
    version, readonly, upgDict) {
        this.fileUtil = new utilsFile_1$1.UtilsFile();
        this.sqliteUtil = new utilsSQLite_1.UtilsSQLite();
        this.jsonUtil = new utilsJson_1$1.UtilsJson();
        //  private _uGlobal: GlobalSQLite = new GlobalSQLite();
        //  private _uEncrypt: UtilsEncryption = new UtilsEncryption();
        this.upgradeUtil = new utilsUpgrade_1.UtilsUpgrade();
        this.importFromJsonUtil = new importFromJson_1.ImportFromJson();
        this.exportToJsonUtil = new exportToJson_1.ExportToJson();
        this.upgradeVersionDict = {};
        this.dbName = dbName;
        //    this._encrypted = encrypted;
        //    this._mode = mode;
        this.version = version;
        this.readonly = readonly;
        this.upgradeVersionDict = upgDict;
        this.pathDB = this.fileUtil.getFilePath(dbName);
        this._isDbOpen = false;
        if (this.pathDB.length === 0)
            throw new Error('Could not generate a path to ' + dbName);
    }
    /**
     * IsDBOpen
     * return the database status
     * @param options: capSQLiteOptions
     * @returns boolean
     * @since 0.0.1
     */
    isDBOpen() {
        return this._isDbOpen;
    }
    /**
     * Open
     * open the @journeyapps/sqlcipher sqlite3 database
     * @returns Promise<boolean>
     */
    async open() {
        this._isDbOpen = false;
        //    let password = '';
        try {
            /*
            if (
              this._encrypted &&
              (this._mode === 'secret' || this._mode === 'encryption')
            ) {
              password = this._uGlobal.secret;
            }
            if (this._mode === 'newsecret') {
              // change the password
              const oPassword: string = this._uGlobal.secret;
              const nPassword: string = this._uGlobal.newsecret;
              await this._uSQLite.changePassword(this._pathDB, oPassword, nPassword);
              password = nPassword;
            }
      
            if (this._mode === 'encryption') {
              await this._uEncrypt.encryptDatabase(this._pathDB, password);
            }
      */
            this.database = await this.sqliteUtil.openOrCreateDatabase(this.pathDB /*,
            password,*/, this.readonly);
            this._isDbOpen = true;
            if (!this.readonly) {
                const curVersion = await this.sqliteUtil.getVersion(this.database);
                console.log(`@@@@ this.readonly: ${this.readonly}`);
                console.log(`@@@@ this.version: ${this.version} curVersion: ${curVersion}`);
                if (this.version > curVersion &&
                    Object.keys(this.upgradeVersionDict).length > 0) {
                    try {
                        await this.fileUtil.copyFileName(this.dbName, `backup-${this.dbName}`);
                        // execute the upgrade flow process
                        await this.upgradeUtil.onUpgrade(this.database, this.upgradeVersionDict, curVersion, this.version);
                        // delete the backup database
                        await this.fileUtil.deleteFileName(`backup-${this.dbName}`);
                    }
                    catch (err) {
                        // restore the database from backup
                        try {
                            await this.fileUtil.restoreFileName(this.dbName, 'backup');
                        }
                        catch (err) {
                            throw new Error(`Open: ${err}`);
                        }
                    }
                }
            }
            return;
        }
        catch (err) {
            if (this._isDbOpen)
                this.close();
            throw new Error(`Open: ${err}`);
        }
    }
    /**
     * Close
     * close the @journeyapps/sqlcipher sqlite3 database
     * @returns Promise<boolean>
     */
    async close() {
        this.ensureDatabaseIsOpen();
        return new Promise((resolve, reject) => {
            this.database.close((err) => {
                if (err) {
                    reject(new Error(`Close failed: ${this.dbName}  ${err}`));
                    return;
                }
                this._isDbOpen = false;
                resolve();
            });
        });
    }
    /**
     * GetVersion
     * get the database version
     * @returns Promise<number>
     */
    async getVersion() {
        this.ensureDatabaseIsOpen();
        try {
            const currentVersion = await this.sqliteUtil.getVersion(this.database);
            return currentVersion;
        }
        catch (err) {
            if (this._isDbOpen)
                this.close();
            throw new Error(`getVersion: ${err}`);
        }
    }
    /**
     * DeleteDB
     * delete a database
     * @param dbName: string
     * @returns Promise<boolean>
     */
    async deleteDB(dbName) {
        // test if file exists
        const isExists = this.fileUtil.isFileExists(dbName);
        if (isExists && !this._isDbOpen) {
            // open the database
            try {
                await this.open();
            }
            catch (err) {
                throw new Error(`DeleteDB: ${err}`);
            }
        }
        // close the database
        try {
            await this.close();
        }
        catch (err) {
            throw new Error('DeleteDB: Close failed');
        }
        // delete the database
        if (isExists) {
            try {
                await this.fileUtil.deleteFileName(dbName);
            }
            catch (err) {
                throw new Error(`DeleteDB: deleteFile ${dbName} failed ${err}`);
            }
        }
        return;
    }
    /**
     * IsTableExists
     * @param tableName
     * @returns
     */
    async isTableExists(tableName) {
        this.ensureDatabaseIsOpen();
        const isOpen = this._isDbOpen;
        try {
            const tableExistsResult = await this.jsonUtil.isTableExists(this.database, isOpen, tableName);
            return tableExistsResult;
        }
        catch (err) {
            throw new Error(`IsTableExists: ${err}`);
        }
    }
    /**
     * CreateSyncTable
     * create the synchronization table
     * @returns Promise<number>
     */
    async createSyncTable() {
        this.ensureDatabaseIsOpen();
        let changes = -1;
        const isOpen = this._isDbOpen;
        // check if the table has already being created
        try {
            const retB = await this.jsonUtil.isTableExists(this.database, isOpen, 'sync_table');
            if (!retB) {
                const isLastModified = await this.sqliteUtil.isLastModified(this.database, isOpen);
                const isSqlDeleted = await this.sqliteUtil.isSqlDeleted(this.database, isOpen);
                if (isLastModified && isSqlDeleted) {
                    const date = Math.round(new Date().getTime() / 1000);
                    let stmts = `
                          CREATE TABLE IF NOT EXISTS sync_table (
                              id INTEGER PRIMARY KEY NOT NULL,
                              sync_date INTEGER
                              );`;
                    stmts += `INSERT INTO sync_table (sync_date) VALUES (
                              "${date}");`;
                    changes = await this.sqliteUtil.execute(this.database, stmts, false);
                    if (changes < 0) {
                        throw new Error(`CreateSyncTable: failed changes < 0`);
                    }
                }
                else {
                    throw new Error('No last_modified/sql_deleted columns in tables');
                }
            }
            else {
                changes = 0;
            }
            return changes;
        }
        catch (err) {
            throw new Error(`CreateSyncTable: ${err}`);
        }
    }
    /**
     * SetSyncDate
     * store the synchronization date
     * @param syncDate: string
     * @returns Promise<{result: boolean, message: string}>
     */
    async setSyncDate(syncDate) {
        this.ensureDatabaseIsOpen();
        try {
            const isTable = await this.jsonUtil.isTableExists(this.database, this._isDbOpen, 'sync_table');
            if (!isTable) {
                throw new Error('No sync_table available');
            }
            const syncDateUnixTimestamp = Math.round(new Date(syncDate).getTime() / 1000);
            let stmt = `UPDATE sync_table SET sync_date = `;
            stmt += `${syncDateUnixTimestamp} WHERE id = 1;`;
            const changes = await this.sqliteUtil.execute(this.database, stmt, false);
            if (changes < 0) {
                return { result: false, message: 'setSyncDate failed' };
            }
            else {
                return { result: true };
            }
        }
        catch (err) {
            return { result: false, message: `setSyncDate failed: ${err}` };
        }
    }
    /**
     * GetSyncDate
     * store the synchronization date
     * @returns Promise<{syncDate: number, message: string}>
     */
    async getSyncDate() {
        this.ensureDatabaseIsOpen();
        try {
            const isTable = await this.jsonUtil.isTableExists(this.database, this._isDbOpen, 'sync_table');
            if (!isTable) {
                throw new Error('No sync_table available');
            }
            const syncDate = await this.exportToJsonUtil.getSyncDate(this.database);
            if (syncDate > 0) {
                return { syncDate };
            }
            else {
                return { syncDate: 0, message: `setSyncDate failed` };
            }
        }
        catch (err) {
            return { syncDate: 0, message: `setSyncDate failed: ${err}` };
        }
    }
    /**
     * ExecuteSQL
     * execute raw sql statements store in a string
     * @param sql: string
     * @returns Promise<number>
     */
    async executeSQL(sql, transaction) {
        this.ensureDatabaseIsOpen();
        try {
            if (transaction) {
                const mode = await this.sqliteUtil.getJournalMode(this.database);
                console.log(`$$$ in executeSQL journal_mode: ${mode} $$$`);
                await this.sqliteUtil.beginTransaction(this.database, this._isDbOpen);
            }
            const changes = await this.sqliteUtil.execute(this.database, sql, false);
            if (changes < 0) {
                throw new Error('ExecuteSQL: changes < 0');
            }
            if (transaction) {
                await this.sqliteUtil.commitTransaction(this.database, this._isDbOpen);
            }
            return changes;
        }
        catch (executeError) {
            let message = `${executeError}`;
            try {
                if (transaction) {
                    await this.sqliteUtil.rollbackTransaction(this.database, this._isDbOpen);
                }
            }
            catch (rollbackErr) {
                message += ` : ${rollbackErr}`;
            }
            throw new Error(`ExecuteSQL: ${message}`);
        }
    }
    /**
     * SelectSQL
     * execute a sql query with/without binding values
     * @param sql: string
     * @param values: string[]
     * @returns Promise<any[]>
     */
    async selectSQL(sql, values) {
        this.ensureDatabaseIsOpen();
        try {
            const selectResult = await this.sqliteUtil.queryAll(this.database, sql, values);
            return selectResult;
        }
        catch (err) {
            throw new Error(`SelectSQL: ${err}`);
        }
    }
    /**
     * runSQL
     * execute a raw sql statement with/without binding values
     * @param sql: string
     * @param values: string[]
     * @returns Promise<{changes:number, lastId:number}>
     */
    async runSQL(statement, values, transaction) {
        this.ensureDatabaseIsOpen();
        const result = { changes: -1, lastId: -1 };
        let initChanges = -1;
        try {
            initChanges = await this.sqliteUtil.dbChanges(this.database);
            // start a transaction
            if (transaction) {
                const mode = await this.sqliteUtil.getJournalMode(this.database);
                console.log(`$$$ in runSQL journal_mode: ${mode} $$$`);
                await this.sqliteUtil.beginTransaction(this.database, this._isDbOpen);
            }
        }
        catch (err) {
            throw new Error(`RunSQL: ${err}`);
        }
        try {
            const lastId = await this.sqliteUtil.prepareRun(this.database, statement, values, false);
            if (lastId < 0) {
                if (transaction) {
                    await this.sqliteUtil.rollbackTransaction(this.database, this._isDbOpen);
                }
                throw new Error(`RunSQL: return LastId < 0`);
            }
            if (transaction) {
                await this.sqliteUtil.commitTransaction(this.database, this._isDbOpen);
            }
            result.changes =
                (await this.sqliteUtil.dbChanges(this.database)) - initChanges;
            result.lastId = lastId;
            return result;
        }
        catch (err) {
            if (transaction) {
                await this.sqliteUtil.rollbackTransaction(this.database, this._isDbOpen);
            }
            throw new Error(`RunSQL: ${err}`);
        }
    }
    /**
     * ExecSet
     * execute a set of raw sql statements with/without binding values
     * @param set: any[]
     * @returns Promise<{changes:number, lastId:number}>
     */
    async execSet(set, transaction) {
        this.ensureDatabaseIsOpen();
        const result = { changes: -1, lastId: -1 };
        let initChanges = -1;
        try {
            initChanges = await this.sqliteUtil.dbChanges(this.database);
            // start a transaction
            if (transaction) {
                const mode = await this.sqliteUtil.getJournalMode(this.database);
                console.log(`$$$ in execSet journal_mode: ${mode} $$$`);
                await this.sqliteUtil.beginTransaction(this.database, this._isDbOpen);
            }
        }
        catch (err) {
            throw new Error(`ExecSet: ${err}`);
        }
        try {
            result.lastId = await this.sqliteUtil.executeSet(this.database, set, false);
            if (transaction) {
                await this.sqliteUtil.commitTransaction(this.database, this._isDbOpen);
            }
            result.changes =
                (await this.sqliteUtil.dbChanges(this.database)) - initChanges;
            return result;
        }
        catch (err) {
            const message = err;
            try {
                if (transaction) {
                    await this.sqliteUtil.rollbackTransaction(this.database, this._isDbOpen);
                }
            }
            catch (err) {
                throw new Error(`ExecSet: ${message}: ` + `${err}`);
            }
        }
    }
    async deleteExportedRows() {
        this.ensureDatabaseIsOpen();
        try {
            await this.exportToJsonUtil.delExportedRows(this.database);
            return;
        }
        catch (err) {
            throw new Error(`DeleteExportedRows: ${err}`);
        }
    }
    /**
     * GetTableList
     * get the table's list
     * @returns
     */
    async getTableList() {
        this.ensureDatabaseIsOpen();
        try {
            const tableNames = await this.sqliteUtil.getTablesNames(this.database);
            return tableNames;
        }
        catch (err) {
            throw new Error(`GetTableList: ${err}`);
        }
    }
    async importJson(jsonData) {
        let changes = 0;
        this.ensureDatabaseIsOpen();
        try {
            // set Foreign Keys Off
            await this.sqliteUtil.setForeignKeyConstraintsEnabled(this.database, false);
            if (jsonData.tables && jsonData.tables.length > 0) {
                // create the database schema
                changes = await this.importFromJsonUtil.createDatabaseSchema(this.database, jsonData);
                if (changes != -1) {
                    // create the tables data
                    changes += await this.importFromJsonUtil.createTablesData(this.database, jsonData);
                }
            }
            if (jsonData.views && jsonData.views.length > 0) {
                // create the views
                changes += await this.importFromJsonUtil.createViews(this.database, jsonData);
            }
            // set Foreign Keys On
            await this.sqliteUtil.setForeignKeyConstraintsEnabled(this.database, true);
            return changes;
        }
        catch (err) {
            throw new Error(`ImportJson: ${err}`);
        }
    }
    async exportJson(mode) {
        const inJson = {};
        inJson.database = this.dbName.slice(0, -9);
        inJson.version = this.version;
        inJson.encrypted = false;
        inJson.mode = mode;
        this.ensureDatabaseIsOpen();
        try {
            const isTable = await this.jsonUtil.isTableExists(this.database, this._isDbOpen, 'sync_table');
            if (isTable) {
                await this.exportToJsonUtil.setLastExportDate(this.database, new Date().toISOString());
            }
            const jsonResult = await this.exportToJsonUtil.createExportObject(this.database, inJson);
            const keys = Object.keys(jsonResult);
            if (keys.length === 0) {
                const msg = `ExportJson: return Object is empty ` + `No data to synchronize`;
                throw new Error(msg);
            }
            const isValid = this.jsonUtil.isJsonSQLite(jsonResult);
            if (isValid) {
                return jsonResult;
            }
            else {
                throw new Error(`ExportJson: retJson not valid`);
            }
        }
        catch (err) {
            throw new Error(`ExportJson: ${err}`);
        }
    }
    /**
     * Throws an error if `this._isDbOpen` is `false`.
     */
    ensureDatabaseIsOpen() {
        if (!this._isDbOpen || !this.database) {
            throw new Error(`getVersion: Database ${this.dbName} is not open yet. You should open it first.`);
        }
    }
}
Database$1.Database = Database;

Object.defineProperty(src, "__esModule", { value: true });
exports.CapacitorSQLite = src.CapacitorSQLite = void 0;
const Database_1 = Database$1;
const utilsJson_1 = utilsJson;
const utilsFile_1 = utilsFile;
class CapacitorSQLite {
    constructor() {
        this.versionUpgrades = {};
        this.databases = {};
        this.fileUtil = new utilsFile_1.UtilsFile();
        this.jsonUtil = new utilsJson_1.UtilsJson();
    }
    async createConnection(options) {
        const optionKeys = Object.keys(options);
        if (!optionKeys.includes('database')) {
            throw new Error('Must provide a database name');
        }
        const dbName = options.database;
        const version = options.version ? options.version : 1;
        /*    const encrypted = false;
        const inMode = "no-encryption";
    
        const encrypted: boolean =
          options.encrypted && this._osType === 'Darwin'
            ? options.encrypted
            : false;
        const inMode: string =
          options.mode && this._osType === 'Darwin'
            ? options.mode
            : 'no-encryption';
        */
        const readonly = options.readonly ? options.readonly : false;
        let upgrades = {};
        const versionUpgradeKeys = Object.keys(this.versionUpgrades);
        if (versionUpgradeKeys.length !== 0 &&
            versionUpgradeKeys.includes(dbName)) {
            upgrades = this.versionUpgrades[dbName];
        }
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const databaseConnection = new Database_1.Database(dbName + 'SQLite.db', 
        /*        encrypted,
        inMode,
        */
        version, readonly, upgrades);
        this.databases[connName] = databaseConnection;
        return;
    }
    async closeConnection(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            // close the database
            try {
                await database.close();
            }
            catch (err) {
                throw new Error(`CloseConnection command failed:  close ${dbName} failed ${err.message}`);
            }
        }
        // remove the connection from dictionary
        delete this.databases[connName];
    }
    async echo(options) {
        const echoValue = this.getOptionValue(options, 'value');
        const echoResult = {};
        echoResult.value = echoValue;
        return echoResult;
    }
    async open(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        try {
            await database.open();
            return;
        }
        catch (err) {
            throw new Error(`Open: ${err}`);
        }
    }
    async close(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            try {
                await database.close();
                return;
            }
            catch (err) {
                throw new Error(`Close: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`Close: ${msg}`);
        }
    }
    async getVersion(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            try {
                const version = await database.getVersion();
                const versionResult = {};
                versionResult.version = version;
                return versionResult;
            }
            catch (err) {
                throw new Error(`GetVersion: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`GetVersion: ${msg}`);
        }
    }
    async getTableList(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            try {
                const tableList = await database.getTableList();
                const tableListResult = {};
                tableListResult.values = tableList;
                return tableListResult;
            }
            catch (err) {
                throw new Error(`GetTableList: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`GetTableList: ${msg}`);
        }
    }
    async execute(options) {
        const dbName = this.getOptionValue(options, 'database');
        const statements = this.getOptionValue(options, 'statements');
        const transaction = this.getOptionValue(options, 'transaction', true);
        const readonly = options.readonly ? options.readonly : false;
        const connName = 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            if (readonly) {
                const msg = 'not allowed in read-only mode ';
                throw new Error(`Execute: ${msg}`);
            }
            try {
                const executeResult = await database.executeSQL(statements, transaction);
                if (executeResult < 0) {
                    throw new Error('Execute changes < 0');
                }
                else {
                    return { changes: { changes: executeResult } };
                }
            }
            catch (err) {
                throw new Error(`Execute: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`Execute: ${msg}`);
        }
    }
    async executeSet(options) {
        const dbName = this.getOptionValue(options, 'database');
        const setOfStatements = this.getOptionValue(options, 'set');
        const transaction = this.getOptionValue(options, 'transaction', true);
        const readonly = options.readonly ? options.readonly : false;
        const connName = 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        for (const sStmt of setOfStatements) {
            if (!('statement' in sStmt) || !('values' in sStmt)) {
                throw new Error('ExecuteSet: Must provide a set as ' + 'Array of {statement,values}');
            }
        }
        if (database.isDBOpen()) {
            if (readonly) {
                const msg = 'not allowed in read-only mode ';
                throw new Error(`ExecuteSet failed: ${msg}`);
            }
            try {
                const execSetResult = await database.execSet(setOfStatements, transaction);
                if (execSetResult < 0) {
                    throw new Error(`ExecuteSet failed changes <0`);
                }
                else {
                    return { changes: execSetResult };
                }
            }
            catch (err) {
                throw new Error(`ExecuteSet failed: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`ExecuteSet failed: ${msg}`);
        }
    }
    async run(options) {
        const dbName = this.getOptionValue(options, 'database');
        const statement = this.getOptionValue(options, 'statement');
        const values = this.getOptionValue(options, 'values', []);
        const transaction = this.getOptionValue(options, 'transaction', true);
        const readonly = options.readonly ? options.readonly : false;
        const connName = 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            if (readonly) {
                const msg = 'not allowed in read-only mode ';
                throw new Error(`Run failed: ${msg}`);
            }
            try {
                const runResult = await database.runSQL(statement, values, transaction);
                return { changes: runResult };
            }
            catch (err) {
                throw new Error(`RUN failed: ${err} `);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`Run failed: ${msg}`);
        }
    }
    async query(options) {
        const dbName = this.getOptionValue(options, 'database');
        const statement = this.getOptionValue(options, 'statement');
        const values = this.getOptionValue(options, 'values', []);
        if (statement.length === 0) {
            throw new Error('Query: Statement may not be an empty string.');
        }
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            try {
                const queryResult = await database.selectSQL(statement, values);
                return { values: queryResult };
            }
            catch (err) {
                throw new Error(`Query: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`Query: ${msg}`);
        }
    }
    async isDBExists(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        this.getDatabaseConnectionOrThrowError(connName);
        //    if (database.isDBOpen()) {
        const isExists = this.fileUtil.isFileExists(dbName + 'SQLite.db');
        return { result: isExists };
        //    } else {
        //      const msg = `Database ${dbName} not opened`;
        //     throw new Error(`isDBExists: ${msg}`);
        //    }
    }
    async isDBOpen(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        const isOpen = database.isDBOpen();
        return { result: isOpen };
    }
    async isDatabase(options) {
        const dbName = this.getOptionValue(options, 'database');
        const isExists = this.fileUtil.isFileExists(dbName + 'SQLite.db');
        return { result: isExists };
    }
    async isTableExists(options) {
        const dbName = this.getOptionValue(options, 'database');
        const tableName = this.getOptionValue(options, 'table');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            try {
                const isTableExistsResult = await database.isTableExists(tableName);
                return { result: isTableExistsResult };
            }
            catch (err) {
                throw new Error(`isTableExists: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`isTableExists: ${msg}`);
        }
    }
    async deleteDatabase(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (readonly) {
            const msg = 'not allowed in read-only mode ';
            throw new Error(`DeleteDatabase failed: ${msg}`);
        }
        try {
            await database.deleteDB(dbName + 'SQLite.db');
            return;
        }
        catch (err) {
            throw new Error(`DeleteDatabase: ${err}`);
        }
    }
    async isJsonValid(options) {
        const jsonString = this.getOptionValue(options, 'jsonstring');
        const jsonObj = JSON.parse(jsonString);
        const isValid = this.jsonUtil.isJsonSQLite(jsonObj);
        if (!isValid) {
            throw new Error('Stringify Json Object not Valid');
        }
        else {
            return { result: true };
        }
    }
    async importFromJson(options) {
        var _a, _b;
        const jsonString = this.getOptionValue(options, 'jsonstring');
        const jsonObj = JSON.parse(jsonString);
        const isValid = this.jsonUtil.isJsonSQLite(jsonObj);
        if (!isValid) {
            throw new Error('Must provide a valid JsonSQLite Object');
        }
        const vJsonObj = jsonObj;
        const dbName = `${vJsonObj.database}SQLite.db`;
        const targetDbVersion = (_a = vJsonObj.version) !== null && _a !== void 0 ? _a : 1;
        const mode = vJsonObj.mode;
        const overwrite = (_b = vJsonObj.overwrite) !== null && _b !== void 0 ? _b : false;
        //    const encrypted: boolean = vJsonObj.encrypted ?? false;
        //    const mode: string = encrypted ? 'secret' : 'no-encryption';
        // Create the database
        const database = new Database_1.Database(dbName, 
        /*encrypted, mode, */
        targetDbVersion, false, {});
        try {
            if (overwrite && mode === 'full') {
                const isExists = this.fileUtil.isFileExists(dbName);
                if (isExists) {
                    await this.fileUtil.deleteFileName(dbName);
                }
            }
            // Open the database
            await database.open();
            const tableList = await database.getTableList();
            if (mode === 'full' && tableList.length > 0) {
                const currentVersion = await database.getVersion();
                if (targetDbVersion < currentVersion) {
                    throw new Error(`ImportFromJson: Cannot import a version lower than ${currentVersion}`);
                }
                if (currentVersion === targetDbVersion) {
                    return { changes: { changes: 0 } };
                }
            }
            // Import the JsonSQLite Object
            const changes = await database.importJson(vJsonObj);
            // Close the database
            await database.close();
            return { changes: { changes: changes } };
        }
        catch (err) {
            throw new Error(`ImportFromJson: ${err}`);
        }
    }
    async exportToJson(options) {
        const dbName = this.getOptionValue(options, 'database');
        const exportMode = this.getOptionValue(options, 'jsonexportmode');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            try {
                const exportJsonResult = await database.exportJson(exportMode);
                const resultKeys = Object.keys(exportJsonResult);
                if (resultKeys.includes('message')) {
                    throw new Error(`exportToJson: ${exportJsonResult.message}`);
                }
                else {
                    return { export: exportJsonResult };
                }
            }
            catch (err) {
                throw new Error(`ExportToJson: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`ExportToJson: ${msg}`);
        }
    }
    async createSyncTable(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            if (readonly) {
                const msg = 'not allowed in read-only mode ';
                throw new Error(`CreateSyncTable failed: ${msg}`);
            }
            try {
                const createTableSyncResult = await database.createSyncTable();
                return {
                    changes: { changes: createTableSyncResult },
                };
            }
            catch (err) {
                throw new Error(`CreateSyncTable: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`CreateSyncTable: ${msg}`);
        }
    }
    async setSyncDate(options) {
        const dbName = this.getOptionValue(options, 'database');
        const syncDate = this.getOptionValue(options, 'syncdate');
        const readonly = options.readonly ? options.readonly : false;
        const connName = 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            if (readonly) {
                const msg = 'not allowed in read-only mode ';
                throw new Error(`SetSyncDate failed: ${msg}`);
            }
            try {
                await database.setSyncDate(syncDate);
                return;
            }
            catch (err) {
                throw new Error(`SetSyncDate: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`SetSyncDate: ${msg}`);
        }
    }
    async getSyncDate(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = readonly ? 'RO_' + dbName : 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            try {
                const ret = await database.getSyncDate();
                return Promise.resolve(ret);
            }
            catch (err) {
                throw new Error(`GetSyncDate: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`GetSyncDate: ${msg}`);
        }
    }
    async deleteExportedRows(options) {
        const dbName = this.getOptionValue(options, 'database');
        const readonly = options.readonly ? options.readonly : false;
        const connName = 'RW_' + dbName;
        const database = this.getDatabaseConnectionOrThrowError(connName);
        if (database.isDBOpen()) {
            if (readonly) {
                const msg = 'not allowed in read-only mode ';
                throw new Error(`DeleteExportedRows: ${msg}`);
            }
            try {
                await database.deleteExportedRows();
                return Promise.resolve();
            }
            catch (err) {
                throw new Error(`DeleteExportedRows: ${err}`);
            }
        }
        else {
            const msg = `Database ${dbName} not opened`;
            throw new Error(`DeleteExportedRows: ${msg}`);
        }
    }
    async addUpgradeStatement(options) {
        const dbName = this.getOptionValue(options, 'database');
        const upgrades = this.getOptionValue(options, 'upgrade');
        for (const upgrade of upgrades) {
            const versionUpgradeKeys = Object.keys(upgrade);
            if (!versionUpgradeKeys.includes('toVersion') ||
                !versionUpgradeKeys.includes('statements')) {
                throw new Error('Must provide an upgrade capSQLiteVersionUpgrade Object');
            }
            if (typeof upgrade.toVersion != 'number') {
                throw new Error('upgrade.toVersion must be a number');
            }
            if (this.versionUpgrades[dbName]) {
                this.versionUpgrades[dbName][upgrade.toVersion] = upgrade;
            }
            else {
                const upgradeVersionDict = {};
                upgradeVersionDict[upgrade.toVersion] = upgrade;
                this.versionUpgrades[dbName] = upgradeVersionDict;
            }
        }
        console.log(`this.versionUpgrades: ${JSON.stringify(this.versionUpgrades)}`);
        return;
    }
    async copyFromAssets(options) {
        const overwrite = this.getOptionValue(options, 'overwrite', false);
        // check if the assets/database folder exists
        const assetsDbPath = this.fileUtil.getAssetsDatabasesPath();
        const pathExists = this.fileUtil.isPathExists(assetsDbPath);
        if (pathExists) {
            // get the database files
            const dbList = await this.fileUtil.getFileList(assetsDbPath);
            // loop through the database files
            dbList.forEach(async (db) => {
                if (this.fileUtil.getExtName(db) === '.db') {
                    // for each copy the file to the Application database folder
                    await this.fileUtil.copyFromAssetToDatabase(db, overwrite);
                }
                if (this.fileUtil.getExtName(db) === '.zip') {
                    const assetPath = this.fileUtil.getAssetsDatabasesPath();
                    await this.fileUtil.unzipDatabase(db, assetPath, overwrite);
                }
            });
            return;
        }
        else {
            throw new Error(`CopyFromAssets: assets/databases folder does not exist:[${assetsDbPath}]`);
        }
    }
    async getFromHTTPRequest(options) {
        const url = this.getOptionValue(options, 'url', '');
        const overwrite = this.getOptionValue(options, 'overwrite', false);
        if (url.length === 0) {
            throw new Error(`getFromHTTPRequest: You must give a database url`);
        }
        const cachePath = this.fileUtil.getCachePath();
        await this.fileUtil.downloadFileFromHTTP(url, cachePath);
        if (this.fileUtil.getExtName(url) === '.zip') {
            const zipName = `${this.fileUtil.getBaseName(url)}.zip`;
            await this.fileUtil.unzipDatabase(zipName, cachePath, overwrite);
        }
        if (overwrite) {
            await this.fileUtil.moveDatabaseFromCache();
        }
        else {
            throw new Error(`getFromHTTPRequest: cannot move file from cache overwrite: ${overwrite}`);
        }
    }
    async getDatabaseList() {
        // get the database folder
        const pathDatabase = this.fileUtil.getDatabasesPath();
        // get the list of databases
        const files = await this.fileUtil.getFileList(pathDatabase);
        if (files.length > 0) {
            return { values: files };
        }
        else {
            throw new Error(`isTableExists: No databases found in [${pathDatabase}]`);
        }
    }
    async checkConnectionsConsistency(options) {
        const dbNames = this.getOptionValue(options, 'dbNames');
        const openModes = this.getOptionValue(options, 'openModes');
        const checkConsistencyResult = {};
        checkConsistencyResult.result = false;
        const dbConns = [];
        dbNames.forEach((value, i) => {
            dbConns.push(`${openModes[i]}_${value}`);
        });
        try {
            let inConnectionsSet = new Set(Object.keys(this.databases));
            const outConnectionSet = new Set(dbConns);
            if (outConnectionSet.size === 0) {
                await this.resetDbDict(Object.keys(this.databases));
                return Promise.resolve(checkConsistencyResult);
            }
            if (inConnectionsSet.size < outConnectionSet.size) {
                await this.resetDbDict(Object.keys(this.databases));
                return Promise.resolve(checkConsistencyResult);
            }
            if (inConnectionsSet.size > outConnectionSet.size) {
                for (const key of inConnectionsSet) {
                    if (!Array.from(outConnectionSet.keys()).includes(key)) {
                        const opt = {};
                        let readonly = false;
                        if (key.substring(0, 3) === 'RO_') {
                            readonly = true;
                        }
                        opt.database = key.substring(3);
                        opt.readonly = readonly;
                        await this.closeConnection(opt);
                    }
                }
            }
            inConnectionsSet = new Set(Object.keys(this.databases));
            if (inConnectionsSet.size === outConnectionSet.size) {
                const symmetricDifferenceSet = await this.symmetricDifference(inConnectionsSet, outConnectionSet);
                if (symmetricDifferenceSet.size === 0) {
                    checkConsistencyResult.result = true;
                    return checkConsistencyResult;
                }
                else {
                    await this.resetDbDict(Object.keys(this.databases));
                    return checkConsistencyResult;
                }
            }
            else {
                await this.resetDbDict(Object.keys(this.databases));
                return checkConsistencyResult;
            }
        }
        catch (err) {
            throw new Error(`CheckConnectionsConsistency: ${err}`);
        }
    }
    async resetDbDict(keys) {
        try {
            for (const key of keys) {
                const opt = {};
                let readonly = false;
                if (key.substring(0, 3) === 'RO_') {
                    readonly = true;
                }
                opt.database = key.substring(3);
                opt.readonly = readonly;
                await this.closeConnection(opt);
            }
        }
        catch (err) {
            throw new Error(`ResetDbDict: ${err}`);
        }
    }
    async symmetricDifference(setA, setB) {
        const difference = new Set(setA);
        for (const elem of setB) {
            if (difference.has(elem)) {
                difference.delete(elem);
            }
            else {
                difference.add(elem);
            }
        }
        return difference;
    }
    /**
     * Returns a database connection, if it already exists.
     * If the conneciton does not exist yet, it throws an error.
     *
     * @param dbName
     * @returns
     */
    getDatabaseConnectionOrThrowError(dbName) {
        const databaseNames = Object.keys(this.databases);
        if (!databaseNames.includes(dbName)) {
            throw new Error(`No connection available for database "${dbName}"`);
        }
        return this.databases[dbName];
    }
    /**
     * Gets the value of an option from the options object.
     * If the `optionKey` does not exist and there is no `defaultValue` defined, an exception is thrown.
     * If the `optionKey` does not exist but there is a `defaultValue`, the `defaultValue` is returned.
     *
     * @param options
     * @param optionKey
     * @param defaultValue
     * @returns
     */
    getOptionValue(options, optionKey, defaultValue = undefined) {
        const optionKeys = Object.keys(options);
        if (!optionKeys.includes(optionKey)) {
            if (defaultValue === undefined) {
                throw new Error(`Must provide "${optionKey}" in options.`);
            }
            else {
                return defaultValue;
            }
        }
        return options[optionKey];
    }
    ////////////////////////////////
    //// UNIMPLEMENTED METHODS
    ////////////////////////////////
    async getMigratableDbList(options) {
        console.log('getCordovaDbList', options);
        throw new Error('Method not implemented.');
    }
    async addSQLiteSuffix(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async deleteOldDatabases(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async moveDatabasesAndAddSuffix(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async getUrl() {
        throw new Error('Method not implemented.');
    }
    async initWebStore() {
        throw new Error('Method not implemented.');
    }
    async saveToStore(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async saveToLocalDisk(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async getFromLocalDiskToStore(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async isSecretStored() {
        throw new Error('Method not implemented.');
    }
    async setEncryptionSecret(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async changeEncryptionSecret(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async clearEncryptionSecret() {
        console.log('clearEncryptionSecret');
        throw new Error('Method not implemented.');
    }
    async checkEncryptionSecret(options) {
        console.log('checkEncryptionSecret', options);
        throw new Error('Method not implemented.');
    }
    async getNCDatabasePath(options) {
        console.log('getNCDatabasePath', options);
        throw new Error('Method not implemented.');
    }
    async createNCConnection(options) {
        console.log('createNCConnection', options);
        throw new Error('Method not implemented.');
    }
    async closeNCConnection(options) {
        console.log('closeNCConnection', options);
        throw new Error('Method not implemented.');
    }
    async isNCDatabase(options) {
        console.log('isNCDatabase', options);
        throw new Error('Method not implemented.');
    }
    async isDatabaseEncrypted(options) {
        console.log('isDatabaseEncrypted', options);
        throw new Error('Not implemented on web.');
    }
    async isInConfigEncryption() {
        throw new Error('Not implemented on web.');
    }
    async isInConfigBiometricAuth() {
        throw new Error('Not implemented on web.');
    }
}
exports.CapacitorSQLite = src.CapacitorSQLite = CapacitorSQLite;

exports["default"] = src;
//# sourceMappingURL=plugin.js.map
